<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[pickle 模块 序列化]]></title>
      <url>%2F2017%2F02%2F13%2Fpython_pickle%2F</url>
      <content type="text"><![CDATA[使用pickle模块将数据对象保存到文件123456789101112131415161718import pickle data1 = &#123;&apos;a&apos;: [1, 2.0, 3, 4+6j], &apos;b&apos;: (&apos;string&apos;, u&apos;Unicode string&apos;), &apos;c&apos;: None&#125; selfref_list = [1, 2, 3]selfref_list.append(selfref_list) output = open(&apos;data.pkl&apos;, &apos;wb&apos;) # Pickle dictionary using protocol 0.pickle.dump(data1, output) # Pickle the list using the highest protocol available.pickle.dump(selfref_list, output, -1) output.close() 使用pickle模块从文件中重构python对象1234567891011import pprint, pickle pkl_file = open(&apos;data.pkl&apos;, &apos;rb&apos;) data1 = pickle.load(pkl_file)pprint.pprint(data1) data2 = pickle.load(pkl_file)pprint.pprint(data2) pkl_file.close()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[time 模块 时间格式]]></title>
      <url>%2F2017%2F02%2F13%2Fpython_time%2F</url>
      <content type="text"><![CDATA[1、sleep(seconds)线程推迟指定的时间运行，单位为秒1time.sleep(10) 2、ctime(seconds) -&gt; string将一个时间戳(默认为当前时间)转换成一个时间字符串12time.ctime()&gt;&gt; &apos;Tue Nov 29 17:51:02 2016&apos; 3、localtime([seconds]) -&gt; (tm_year,tm_mon,tm_day,tm_hour,tm_min,tm_sec,tm_wday,tm_yday,tm_isdst)将一个时间戳转换成一个当前时区的struct_time，如果seconds参数未输入，则以当前时间为转换标准12time.localtime(time.time())&gt;&gt; time.struct_time(tm_year=2016, tm_mon=11, tm_mday=29, tm_hour=17, tm_min=52, tm_sec=14, tm_wday=1, tm_yday=334, tm_isdst=0) 4、strftime(format[, tuple]) -&gt; string将指定的struct_time(默认为当前时间)，根据指定的格式化字符串输出12time.strftime(&apos;%Y-%m-%d_%H-%M-%S&apos;,time.localtime())&gt;&gt; &apos;2016-11-29_17-57-51&apos; python中时间日期格式化符号： %y 两位数的年份表示（00-99） %Y 四位数的年份表示（000-9999） %m 月份（01-12） %d 月内中的一天（0-31） %H 24小时制小时数（0-23） %I 12小时制小时数（01-12） %M 分钟数（00=59） %S 秒（00-59） %a 本地简化星期名称 %A 本地完整星期名称 %b 本地简化的月份名称 %B 本地完整的月份名称 %c 本地相应的日期表示和时间表示 %j 年内的一天（001-366） %p 本地A.M.或P.M.的等价符 %U 一年中的星期数（00-53）星期天为星期的开始 %w 星期（0-6），星期天为星期的开始 %W 一年中的星期数（00-53）星期一为星期的开始 %x 本地相应的日期表示 %X 本地相应的时间表示 %Z 当前时区的名称 %% %号本身 5、strptime(string, format) -&gt; struct_time将时间字符串根据指定的格式化符转换成数组形式的时间]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[例子]]></title>
      <url>%2F2017%2F02%2F13%2Fhive_hadoop_example%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617CREATE TABLE dev.tmp_check_sku_20161202ASSELECT a.item_sku_id, b.sku_idFROM (SELECT item_sku_id,dt FROM gdm.gdm_m03_item_sku_da WHERE dt= &apos;2016-10-08&apos; AND sku_valid_flag=1) A FULL OUTER JOIN (SELECT sku_id,dt FROM gdm.gdm_m08_item_stock_day_sum WHERE dt= &apos;2016-10-08&apos; ) B ON a.item_sku_id=b.sku_id 1234567891011121314-- 统计数据SELECT CASE WHEN item_sku_id IS NOT NULL THEN 1 ELSE 0 END AS item_sku_cnt, CASE WHEN sku_id IS NOT NULL THEN 1 ELSE 0 END AS sku_cnt, count(1)FROM dev.tmp_check_sku_20161202GROUP BY CASE WHEN item_sku_id IS NOT NULL THEN 1 ELSE 0 END, CASE WHEN sku_id IS NOT NULL THEN 1 ELSE 0 END-- 结果1 0 1 7074892 1 0 8320842583 1 1 81142196]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基本命令]]></title>
      <url>%2F2017%2F02%2F13%2Fhive_hadoop_base%2F</url>
      <content type="text"><![CDATA[1、设置动态分区12set hive.exec.dynamic.partition=true;set hive.exec.dynamic.partition.mode=nonstrict; 2、设置最大动态分区12set hive.exec.max.dynamic.partitions=2000;set hive.exec.max.dynamic.partitions.pernode=2000; 3、创建动态分区表12345678910111213141516CREATE TABLE IF NOT EXISTS dev.dev_allocation_sale_data ( org_dc_id string, sale_ord_det_id string, sale_ord_id string, parent_sale_ord_id string, item_sku_id string, -- skuid sale_qtty int, -- 销售数量 sale_ord_tm string, -- 销售订单订购时间 sale_ord_type string, -- 订单配送类型 sale_ord_white_flag string, -- 是否包括白名单 item_third_cate_cd string, --sku所属三级分类 item_second_cate_cd string, --sku所属二级分类 shelves_dt string, --上架日期 shelves_tm string --上架时间 ) PARTITIONED by (date_s string,dc_id int); 4、插入动态分区表1234567891011121314insert overwrite table dev.dev_allocation_sale_data partition(date_s,dc_id)select a.org_dc_id, case when b.sale_ord_id is not null then &apos;rdc&apos; when c.sale_ord_id is not null then &apos;fdc_rdc&apos; when d.sale_ord_id is not null then &apos;fdc&apos; else &apos;other&apos; end, d.white_flag, a.item_third_cate_cd, a.item_second_cate_cd, a.shelves_dt, a.shelves_tm, a.dt as date_s, a.dc_idfrom dev.tmp_allocation_order_data_mid01 a 5、取出hive数据12INSERT OVERWRITE LOCAL DIRECTORY &apos;/home/cmo_ipc/Allocation_shell/datasets/sku_datasets&apos; select * from dev.dev_allocation_fdc_data; 动态分区http://blog.csdn.net/kntao/article/details/38683645 http://blog.csdn.net/chenyi8888/article/details/8236726]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[awk]]></title>
      <url>%2F2017%2F02%2F13%2Flinux_awk%2F</url>
      <content type="text"><![CDATA[1、简单例子1awk &apos;BEGIN &#123;print &quot;Hello world!&quot;&#125;&apos; # 这个不需要文件输入就可以 awkscr文件：1/^$/ &#123;print &quot;This is a blank line&quot;&#125; 运行脚本文件awkscr对应于test文件：1awk -f awkscr test 例子1echo a b c d | awk &apos;&#123;one=1;two=2&#125;&#123;print $(one + two)&#125;&apos; -F “\t” ：表示分隔符为\tFS：表示分隔符 灵活指定分隔符，正则指定1234BEGIN &#123;FS=&quot;,&quot;&#125;&#123;print $1 &quot;,&quot; $6&#125; # 使用，为分隔符FS=&quot;\t&quot; # 指定一个 tab 为分隔符FS=&quot;\t+&quot; # 指定一个以上的 tab 为分隔符【正则】FS=&quot;[&apos;:\t]&quot; # 指定&apos;、:、 tab 中任何一个为分隔符 2、模式匹配123awk &apos;/^$/ &#123;print &quot;This is a blank line&quot;&#125;&apos; testawk &apos;/[0-9]/ &#123;print &quot;This is a blank line&quot;&#125;&apos; testawk &apos;/[A-Za-z]/ &#123;print &quot;This is a blank line&quot;&#125;&apos; test http://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html http://awk.readthedocs.io/en/latest/chapter-one.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sz-rz-文件传输]]></title>
      <url>%2F2017%2F02%2F13%2Flinux_03_rzsz%2F</url>
      <content type="text"><![CDATA[Xshell1、sz用法（下载）：下载一个文件1sz filename 下载多个文件1sz filename1 filename2 下载dir目录下的所有文件，不包含dir下的文件夹1sz dir/* 2、rz用法（上传）：输入rz回车后，会出现文件选择对话框，选择需要上传文件，一次可以指定多个文件，上传到服务器的路径为当前执行rz命令的目录。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux 查看系统信息命令(比较全)]]></title>
      <url>%2F2017%2F02%2F13%2Flinux_02_com%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637# uname -a # 查看内核/操作系统/CPU信息# head -n 1 /etc/issue # 查看操作系统版本# cat /proc/cpuinfo # 查看CPU信息# hostname # 查看计算机名# lspci -tv # 列出所有PCI设备# lsusb -tv # 列出所有USB设备# lsmod # 列出加载的内核模块# env # 查看环境变量资源# free -m # 查看内存使用量和交换区使用量# df -h # 查看各分区使用情况# du -sh &lt;目录名&gt; # 查看指定目录的大小# grep MemTotal /proc/meminfo # 查看内存总量# grep MemFree /proc/meminfo # 查看空闲内存量# uptime # 查看系统运行时间、用户数、负载# cat /proc/loadavg # 查看系统负载磁盘和分区# mount | column -t # 查看挂接的分区状态# fdisk -l # 查看所有分区# swapon -s # 查看所有交换分区# hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备)# dmesg | grep IDE # 查看启动时IDE设备检测状况网络# ifconfig # 查看所有网络接口的属性# iptables -L # 查看防火墙设置# route -n # 查看路由表# netstat -lntp # 查看所有监听端口# netstat -antp # 查看所有已经建立的连接# netstat -s # 查看网络统计信息进程# ps -ef # 查看所有进程# top # 实时显示进程状态用户# w # 查看活动用户# id &lt;用户名&gt; # 查看指定用户信息# last # 查看用户登录日志# cut -d: -f1 /etc/passwd # 查看系统所有用户# cut -d: -f1 /etc/group # 查看系统所有组# crontab -l # 查看当前用户的计划任务服务# chkconfig –list # 列出所有系统服务# chkconfig –list | grep on # 列出所有启动的系统服务程序# rpm -qa # 查看所有安装的软件包]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一些常用命令]]></title>
      <url>%2F2017%2F02%2F13%2Flinux_01_base%2F</url>
      <content type="text"><![CDATA[一、基本命令（1）查看linux的信息12345uname -alsb_release -acat /etc/redhat-release # 查看服务器是Ubuntu还是Centosfile /sbin/init 或者file /bin/ls # 查看服务器是32、64位free -g # 以G为单位，查看内存大小 （2）查看某文件夹下，文件夹的文件大小总和1du -h --max-depth=1 # 深度为1的文件夹里面文件的总大小 （3）查找某文件的路径1find /data0 -name filename # /data0表示目录文件，只找/data0下的名字叫filename的文件 （4）管道使用ls1find /data0 -name filename | xargs ls -l 二、基本配置（1）vim使用鼠标在.vimrc中添加set mouse=a这句话，具体还有别的模式，这里不在叙述，尝试用a最合适。 （2）vim显示行号1:set number 三、日期命令输出日期1234567date=`date -d &quot;+0 day $1&quot; +%Y-%m-%d`enddate=`date -d &quot;+1 day $2&quot; +%Y-%m-%d`while [[ $date &lt; $enddate ]]do echo $date date=`date -d &quot;+1 day $date&quot; +%Y-%m-%d`done 123451) ls -lt 时间最近的在前面2) ls -ltr 时间从前到后3) 利用sort ls -l | sort +7 (日期为第8列) 时间从前到后 ls -l | sort -r +7 时间最近的在前面 四、查看进程和杀死进程123ps -efps -auxkill -s 9 1827 # 9是强制、尽快终止进程。1827是PID进程号 五、命令1wc -l filename # 显示文件的行数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Advanced Statistics]]></title>
      <url>%2F2017%2F01%2F25%2Fadvanced_statistics%2F</url>
      <content type="text"><![CDATA[Advanced StatisticsTransformations of Random VariablesLet me set the example;You have two independant random variables $X$ with pdf $f_{X}(x)$ and $Y$ with pdf $f_{Y}(y)$.You will have a new random variable $Z$, where $Z=X-Y$, and say we want to calculate the marginal pdf of $Z$.First we need to make a new joint pdf including Z, to avoid cluterization of the same random variables, lets first let give $X$ a different name, i.e. $X=W$.Now we saw that we have $Z=X-Y$, but now its $Z=W-Y$.We want to know our variable $Y$, so we re-arrange the above to get $Y=W-Z$. Now, we use something called a Jacobian, and we will use its determinant to transform from $(x,y)$ to $(w,z)$, and then we can get the marginal pdf of $Z$.So the jacobian is:$$|J|=|\frac{\partial(x,y)}{\partial(w,z)}|=\begin{vmatrix}\frac{\partial x}{\partial w} &amp; \frac{\partial y}{\partial w} \\\\frac{\partial x}{\partial z} &amp; \frac{\partial y}{\partial z}\end{vmatrix}$$We can then do the following:$$f_{Z,W}=f_{X,Y}(w,w-Z)|J|$$$$=f_{X}(w)f_{Y}(w-z) \cdot |J|$$And then finally, to find the marginal pdf of $Z$, we intergrate out w from the joint pdf:$$f_{Z}(z)=\int_{-\infty}^{\infty}f_{X}(w)f_{Y}(w-z)dw$$]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F01%2F24%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
