<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Tutorial_7 Customizing the admin site]]></title>
      <url>%2F2017%2F04%2F23%2Fpython_django_tutorial_07%2F</url>
      <content type="text"><![CDATA[一、管理admin1、修改顺序1234567from django.contrib import adminfrom .models import Questionclass QuestionAdmin(admin.ModelAdmin): fields = [&apos;pub_date&apos;, &apos;question_text&apos;]admin.site.register(Question, QuestionAdmin) 使得pub_date显示在question_text前面。 2、修改标题12345class QuestionAdmin(admin.ModelAdmin): fieldsets = [ (None, &#123;&apos;fields&apos;: [&apos;question_text&apos;]&#125;), (&apos;Date information&apos;, &#123;&apos;fields&apos;: [&apos;pub_date&apos;]&#125;), ] 使得显示的标题信息增加。 3、增加投票信息123456789101112131415from django.contrib import adminfrom .models import Choice, Questionclass ChoiceInline(admin.StackedInline): model = Choice extra = 3class QuestionAdmin(admin.ModelAdmin): fieldsets = [ (None, &#123;&apos;fields&apos;: [&apos;question_text&apos;]&#125;), (&apos;Date information&apos;, &#123;&apos;fields&apos;: [&apos;pub_date&apos;], &apos;classes&apos;: [&apos;collapse&apos;]&#125;), ] inlines = [ChoiceInline]admin.site.register(Question, QuestionAdmin) 使用内联式的会更好。12class ChoiceInline(admin.TabularInline): #... 4、列表信息123class QuestionAdmin(admin.ModelAdmin): # ... list_display = (&apos;question_text&apos;, &apos;pub_date&apos;, &apos;was_published_recently&apos;) 5、添加filtermodels里添加。12345678class Question(models.Model): # ... def was_published_recently(self): now = timezone.now() return now - datetime.timedelta(days=1) &lt;= self.pub_date &lt;= now was_published_recently.admin_order_field = &apos;pub_date&apos; was_published_recently.boolean = True was_published_recently.short_description = &apos;Published recently?&apos; admin里的QuestionAdmin添加。1list_filter = [&apos;pub_date&apos;] 6、添加搜索admin里的QuestionAdmin添加。1search_fields = [&apos;question_text&apos;] 二、建立app的admin在app的templates文件夹下建立admin文件夹，将django/contrib/admin/templates/admin/base_site.html拷贝到templates/admin/下。修改指定部分123&#123;% block branding %&#125;&lt;h1 id=&quot;site-name&quot;&gt;&lt;a href=&quot;&#123;% url &apos;admin:index&apos; %&#125;&quot;&gt;Polls Administration&lt;/a&gt;&lt;/h1&gt;&#123;% endblock %&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tutorial_6 Static files]]></title>
      <url>%2F2017%2F04%2F23%2Fpython_django_tutorial_06%2F</url>
      <content type="text"><![CDATA[一、静态文件创建static在app的目录下，polls/static/。和建立templates类似，还需要在建立app名字命名的文件夹。将文件放于其下polls/static/polls/。 1.1 添加css建立css文件夹，再建立style.css，写入：123li a &#123; color: green;&#125; 修改index.html12&#123;% load static %&#125;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&#123;% static &apos;polls/css/style.css&apos; %&#125;&quot; /&gt; 1.2 添加图片建立文件夹polls/static/polls/images，在其中放置background_001.jpg。添加。123body &#123; background: white url(&quot;../images/background_001.jpg&quot;) no-repeat right bottom;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tutorial_5 Testing]]></title>
      <url>%2F2017%2F04%2F23%2Fpython_django_tutorial_05%2F</url>
      <content type="text"><![CDATA[一、测试写测试类，在app的tests.py文件下。1234567891011121314import datetimefrom django.utils import timezonefrom django.test import TestCasefrom .models import Questionclass QuestionMethodTests(TestCase): def test_was_published_recently_with_future_question(self): &quot;&quot;&quot; was_published_recently() should return False for questions whose pub_date is in the future. &quot;&quot;&quot; time = timezone.now() + datetime.timedelta(days=30) future_question = Question(pub_date=time) self.assertIs(future_question.was_published_recently(), False) 在终端运行。1python manage.py test polls 会显示错误。其中，运行步骤为：1、该命令寻找polls的app2、发现一个django.test.TestCase的类3、创建特殊数据库来测试4、寻找以test为名字开始的函数test_was_published_recently_with_future_question。在调用其中的方法。修改bug。models.py中的该函数部分。123def was_published_recently(self): now = timezone.now() return now - datetime.timedelta(days=1) &lt;= self.pub_date &lt;= now 更加复杂的测试，应该加入到test.py文件中。1234567891011121314151617def test_was_published_recently_with_old_question(self): &quot;&quot;&quot; was_published_recently() should return False for questions whose pub_date is older than 1 day. &quot;&quot;&quot; time = timezone.now() - datetime.timedelta(days=30) old_question = Question(pub_date=time) self.assertIs(old_question.was_published_recently(), False)def test_was_published_recently_with_recent_question(self): &quot;&quot;&quot; was_published_recently() should return True for questions whose pub_date is within the last day. &quot;&quot;&quot; time = timezone.now() - datetime.timedelta(hours=1) recent_question = Question(pub_date=time) self.assertIs(recent_question.was_published_recently(), True) 测试还有别的内容，之后再看。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tutorial_4 Forms and generic views]]></title>
      <url>%2F2017%2F04%2F23%2Fpython_django_tutorial_04%2F</url>
      <content type="text"><![CDATA[12345678910&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&#123;% if error_message %&#125;&lt;p&gt;&lt;strong&gt;&#123;&#123; error_message &#125;&#125;&lt;/strong&gt;&lt;/p&gt;&#123;% endif %&#125;&lt;form action=&quot;&#123;% url &apos;polls:vote&apos; question.id %&#125;&quot; method=&quot;post&quot;&gt;&#123;% csrf_token %&#125;&#123;% for choice in question.choice_set.all %&#125; &lt;input type=&quot;radio&quot; name=&quot;choice&quot; id=&quot;choice&#123;&#123; forloop.counter &#125;&#125;&quot; value=&quot;&#123;&#123; choice.id &#125;&#125;&quot; /&gt; &lt;label for=&quot;choice&#123;&#123; forloop.counter &#125;&#125;&quot;&gt;&#123;&#123; choice.choice_text &#125;&#125;&lt;/label&gt;&lt;br /&gt;&#123;% endfor %&#125;&lt;input type=&quot;submit&quot; value=&quot;Vote&quot; /&gt;&lt;/form&gt; 其中forloop.counter是指for循环了多少次。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tutorial_3 Views and templates]]></title>
      <url>%2F2017%2F04%2F23%2Fpython_django_tutorial_03%2F</url>
      <content type="text"><![CDATA[一、视图添加更多的视图，在app的views.py下：123456789def detail(request, question_id): return HttpResponse(&quot;You&apos;re looking at question %s.&quot; % question_id)def results(request, question_id): response = &quot;You&apos;re looking at the results of question %s.&quot; return HttpResponse(response % question_id)def vote(request, question_id): return HttpResponse(&quot;You&apos;re voting on question %s.&quot; % question_id) 添加了视图之后，我们需要把相应的url添加到app下的urls.py文件：12345678910111213from django.conf.urls import urlfrom . import viewsurlpatterns = [ # ex: /polls/ url(r&apos;^$&apos;, views.index, name=&apos;index&apos;), # ex: /polls/5/ url(r&apos;^(?P&lt;question_id&gt;[0-9]+)/$&apos;, views.detail, name=&apos;detail&apos;), # ex: /polls/5/results/ url(r&apos;^(?P&lt;question_id&gt;[0-9]+)/results/$&apos;, views.results, name=&apos;results&apos;), # ex: /polls/5/vote/ url(r&apos;^(?P&lt;question_id&gt;[0-9]+)/vote/$&apos;, views.vote, name=&apos;vote&apos;),] 二、模板创建templates文件夹，创建模板文件在polls/templates/polls，创建index.html。123456789&#123;% if latest_question_list %&#125; &lt;ul&gt; &#123;% for question in latest_question_list %&#125; &lt;li&gt;&lt;a href=&quot;/polls/&#123;&#123; question.id &#125;&#125;/&quot;&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt;&#123;% else %&#125; &lt;p&gt;No polls are available.&lt;/p&gt;&#123;% endif %&#125; 修改视图1234567891011from django.http import HttpResponsefrom django.template import loaderfrom .models import Questiondef index(request): latest_question_list = Question.objects.order_by(&apos;-pub_date&apos;)[:5] template = loader.get_template(&apos;polls/index.html&apos;) context = &#123; &apos;latest_question_list&apos;: latest_question_list, &#125; return HttpResponse(template.render(context, request)) 上面使用的HttpResponse的方法较为麻烦，可以使用快捷方式。1234567from django.shortcuts import renderfrom .models import Questiondef index(request): latest_question_list = Question.objects.order_by(&apos;-pub_date&apos;)[:5] context = &#123;&apos;latest_question_list&apos;: latest_question_list&#125; return render(request, &apos;polls/index.html&apos;, context) 三、404在app下templates/polls/建立文件detail.html。修改视图1234567891011from django.http import Http404from django.shortcuts import renderfrom .models import Question# ...def detail(request, question_id): try: question = Question.objects.get(pk=question_id) except Question.DoesNotExist: raise Http404(&quot;Question does not exist&quot;) return render(request, &apos;polls/detail.html&apos;, &#123;&apos;question&apos;: question&#125;) 快捷方式1234567from django.shortcuts import get_object_or_404, renderfrom .models import Question# ...def detail(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, &apos;polls/detail.html&apos;, &#123;&apos;question&apos;: question&#125;) 修改detail.html文件123456&lt;h1&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/h1&gt;&lt;ul&gt;&#123;% for choice in question.choice_set.all %&#125; &lt;li&gt;&#123;&#123; choice.choice_text &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; 四、移除硬url在html中写url的时候，不要使用硬url，如：1&lt;li&gt;&lt;a href=&quot;/polls/&#123;&#123; question.id &#125;&#125;/&quot;&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt; 要如下：1&lt;li&gt;&lt;a href=&quot;&#123;% url &apos;detail&apos; question.id %&#125;&quot;&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt; 在添加url的命名空间在app的urls.py中添加app_name12345678910from django.conf.urls import urlfrom . import viewsapp_name = &apos;polls&apos;urlpatterns = [ url(r&apos;^$&apos;, views.index, name=&apos;index&apos;), url(r&apos;^(?P&lt;question_id&gt;[0-9]+)/$&apos;, views.detail, name=&apos;detail&apos;), url(r&apos;^(?P&lt;question_id&gt;[0-9]+)/results/$&apos;, views.results, name=&apos;results&apos;), url(r&apos;^(?P&lt;question_id&gt;[0-9]+)/vote/$&apos;, views.vote, name=&apos;vote&apos;),] 添加url的命名空间1&lt;li&gt;&lt;a href=&quot;&#123;% url &apos;polls:detail&apos; question.id %&#125;&quot;&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tutorial_2 Models and the admin site]]></title>
      <url>%2F2017%2F04%2F23%2Fpython_django_tutorial_02%2F</url>
      <content type="text"><![CDATA[一、数据库Django默认使用的是SQLite，如果想使用别的，可以在项目的settings下修改： ENGINE : ‘django.db.backends.sqlite3’, ‘django.db.backends.postgresql’, ‘django.db.backends.mysql’, or ‘django.db.backends.oracle’等等。 如果不使用SQLite的话， USER, PASSWORD和 HOST的信息必须被添加。 二、Models2.1 创建在app的models.py下创建models写入12345678910from django.db import modelsclass Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField(&apos;date published&apos;)class Choice(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) 使用的是ORM对象关系映射。 2.2 激活建立了polls这个app后，在polls/apps下面有PollsConfig这个类。将其添加到project的settings下面的INSTALLED_APPS。123456789INSTALLED_APPS = [ &apos;polls.apps.PollsConfig&apos;, &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;,] 2.3 迁移然后迁移migrations。1python manage.py makemigrations polls 会看见类似：12345Migrations for &apos;polls&apos;: polls/migrations/0001_initial.py: - Create model Choice - Create model Question - Add field question to choice 则会在app的migrations下面产生0001_initial.py文件，适用于记录产生的models变化。可以使用sqlmigrate查看。1python manage.py sqlmigrate polls 0001 会看到类似：1234567891011121314151617181920212223242526272829BEGIN;---- Create model Choice--CREATE TABLE &quot;polls_choice&quot; ( &quot;id&quot; serial NOT NULL PRIMARY KEY, &quot;choice_text&quot; varchar(200) NOT NULL, &quot;votes&quot; integer NOT NULL);---- Create model Question--CREATE TABLE &quot;polls_question&quot; ( &quot;id&quot; serial NOT NULL PRIMARY KEY, &quot;question_text&quot; varchar(200) NOT NULL, &quot;pub_date&quot; timestamp with time zone NOT NULL);---- Add field question to choice--ALTER TABLE &quot;polls_choice&quot; ADD COLUMN &quot;question_id&quot; integer NOT NULL;ALTER TABLE &quot;polls_choice&quot; ALTER COLUMN &quot;question_id&quot; DROP DEFAULT;CREATE INDEX &quot;polls_choice_7aa0f6ee&quot; ON &quot;polls_choice&quot; (&quot;question_id&quot;);ALTER TABLE &quot;polls_choice&quot; ADD CONSTRAINT &quot;polls_choice_question_id_246c99a640fbbd72_fk_polls_question_id&quot; FOREIGN KEY (&quot;question_id&quot;) REFERENCES &quot;polls_question&quot; (&quot;id&quot;) DEFERRABLE INITIALLY DEFERRED;COMMIT; 注意：1、这个sql是依赖于所用的数据库2、表名被自动生成（查看是怎么样的） 2.4 生成再次使用migrate1python manage.py migrate 三、Shell进入shell中1python manage.py shell 开始调试1234567891011from polls.models import Question, Choice # Import the model classes we just wrote.Question.objects.all()from django.utils import timezoneq = Question(question_text=&quot;What&apos;s new?&quot;, pub_date=timezone.now())q.save()q.idq.question_textq.pub_dateq.question_text = &quot;What&apos;s up?&quot;q.save()Question.objects.all() 在使用Question.objects.all()得到的&lt;QuerySet [&lt;Question: Question object&gt;]&gt;结果是没有什么直接用处的。我们可以修改app下的model.py文件。123456789101112131415161718192021import datetimefrom django.db import modelsfrom django.utils.encoding import python_2_unicode_compatiblefrom django.utils import timezone@python_2_unicode_compatibleclass Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField(&apos;date published&apos;) def __str__(self): return self.question_text def was_published_recently(self): return self.pub_date &gt;= timezone.now() - datetime.timedelta(days=1)@python_2_unicode_compatibleclass Choice(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) def __str__(self): return self.choice_text 在原有代码的情况下，添加__str__的方法。上面还添加了一个was_published_recently的方法。123456789101112131415Question.objects.filter(id=1)Question.objects.filter(question_text__startswith=&apos;What&apos;)from django.utils import timezonecurrent_year = timezone.now().yearQuestion.objects.get(pub_date__year=current_year)Question.objects.get(pk=1)q = Question.objects.get(pk=1)q.was_published_recently()q.choice_set.create(choice_text=&apos;Not much&apos;, votes=0)q.choice_set.create(choice_text=&apos;The sky&apos;, votes=0)c = q.choice_set.create(choice_text=&apos;Just hacking again&apos;, votes=0)q.choice_set.count()Choice.objects.filter(question__pub_date__year=current_year)c = q.choice_set.filter(choice_text__startswith=&apos;Just hacking&apos;)c.delete() 四、Admin创建superuser1python manage.py createsuperuser 在 http://127.0.0.1:8000/admin/ 中可以登录。我们需要告诉admin有polls中的models的接口，在app的admin.py文件下：12345from django.contrib import adminfrom .models import Question, Choiceadmin.site.register(Question)admin.site.register(Choice)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tutorial_1 Request and Response]]></title>
      <url>%2F2017%2F04%2F23%2Fpython_django_tutorial_01%2F</url>
      <content type="text"><![CDATA[一、创建一个Project1django-admin startproject longgb246 产生目录1234567longgb246/ manage.py mysite/ __init__.py settings.py urls.py wsgi.py 二、开启服务1python manage.py runserver 端口号：http://127.0.0.1:8000/还可以改变端口，或者IP12python manage.py runserver 8080python manage.py runserver 0.0.0.0:8000 三、开启app1python manage.py startapp polls 得到以下目录123456789polls/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py 3.1 写第一个view打开polls/views.py写入123from django.http import HttpResponsedef index(request): return HttpResponse(&quot;Hello, world. You&apos;re at the polls index.&quot;) 3.2 创建app的urls得到以下目录12345678910polls/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py urls.py views.py 在urls.py中写到12345from django.conf.urls import urlfrom . import viewsurlpatterns = [ url(r&apos;^$&apos;, views.index, name=&apos;index&apos;),] 3.3 创建项目的urls在目录的urls.py下写入123456from django.conf.urls import include, urlfrom django.contrib import adminurlpatterns = [ url(r&apos;^polls/&apos;, include(&apos;polls.urls&apos;)), url(r&apos;^admin/&apos;, admin.site.urls),] 把polls写入其中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jieba结巴分词使用]]></title>
      <url>%2F2017%2F03%2F12%2Fpython_jieba%2F</url>
      <content type="text"><![CDATA[概念解释通过用户自定义词典来增强歧义纠错能力。https://github.com/fxsjy/jieba/issues/14 1、分词函数 jieba.cut 方法接受三个输入参数: 需要分词的字符串；cut_all 参数用来控制是否采用全模式；HMM 参数用来控制是否使用 HMM 模型 jieba.cut_for_search 方法接受两个参数：需要分词的字符串；是否使用 HMM 模型。该方法适合用于搜索引擎构建倒排索引的分词，粒度比较细 jieba.Tokenizer(dictionary=DEFAULT_DICT) 新建自定义分词器，可用于同时使用不同词典。 jieba.dt 为默认分词器，所有全局分词相关函数都是该分词器的映射。 注意： 待分词的字符串可以是 unicode 或 UTF-8 字符串、GBK 字符串。注意：不建议直接输入 GBK 字符串，可能无法预料地错误解码成 UTF-82.jieba.cut 以及 jieba.cut_for_search 返回的结构都是一个可迭代的 generator，可以使用 for 循环来获得分词后得到的每一个词语(unicode)，或者用jieba.lcut 以及 jieba.lcut_for_search 直接返回 list 2、添加自定义词典 用法： jieba.load_userdict(file_name) # file_name 为文件类对象或自定义词典的路径 词典格式和 dict.txt 一样，一个词占一行；每一行分三部分：词语、词频（可省略）、词性（可省略），用空格隔开，顺序不可颠倒。file_name 若为路径或二进制方式打开的文件，则文件必须为 UTF-8 编码。 词频省略时使用自动计算的能保证分出该词的词频。例如：1234创新办 3 i云计算 5凱特琳 nz台中 调整词典 使用 add_word(word, freq=None, tag=None) 和 del_word(word) 可在程序中动态修改词典。 使用 suggest_freq(segment, tune=True) 可调节单个词语的词频，使其能（或不能）被分出来。 注意：自动计算的词频在使用 HMM 新词发现功能时可能无效。代码示例：123456789101112&gt;&gt;&gt; print(&apos;/&apos;.join(jieba.cut(&apos;如果放到post中将出错。&apos;, HMM=False)))如果/放到/post/中将/出错/。&gt;&gt;&gt; jieba.suggest_freq((&apos;中&apos;, &apos;将&apos;), True)494&gt;&gt;&gt; print(&apos;/&apos;.join(jieba.cut(&apos;如果放到post中将出错。&apos;, HMM=False)))如果/放到/post/中/将/出错/。&gt;&gt;&gt; print(&apos;/&apos;.join(jieba.cut(&apos;「台中」正确应该不会被切开&apos;, HMM=False)))「/台/中/」/正确/应该/不会/被/切开&gt;&gt;&gt; jieba.suggest_freq(&apos;台中&apos;, True)69&gt;&gt;&gt; print(&apos;/&apos;.join(jieba.cut(&apos;「台中」正确应该不会被切开&apos;, HMM=False)))「/台中/」/正确/应该/不会/被/切开 3、关键词提取基于 TF-IDF 算法的关键词抽取import jieba.analyse jieba.analyse.extract_tags(sentence, topK=20, withWeight=False, allowPOS=()) sentence 为待提取的文本 topK 为返回几个 TF/IDF 权重最大的关键词，默认值为 20 withWeight 为是否一并返回关键词权重值，默认值为 False allowPOS 仅包括指定词性的词，默认值为空，即不筛选 jieba.analyse.TFIDF(idf_path=None) 新建 TFIDF 实例，idf_path 为 IDF 频率文件代码示例 （关键词提取）https://github.com/fxsjy/jieba/blob/master/test/extract_tags.py 语料库切换逆向文件频率（IDF）文本语料库关键词提取所使用逆向文件频率（IDF）文本语料库可以切换成自定义语料库的路径 用法： jieba.analyse.set_idf_path(file_name) # file_name为自定义语料库的路径 自定义语料库示例：https://github.com/fxsjy/jieba/blob/master/extra_dict/idf.txt.big 用法示例：https://github.com/fxsjy/jieba/blob/master/test/extract_tags_idfpath.py停止词（Stop Words）文本语料库关键词提取所使用停止词（Stop Words）文本语料库可以切换成自定义语料库的路径 用法： jieba.analyse.set_stop_words(file_name) # file_name为自定义语料库的路径 自定义语料库示例：https://github.com/fxsjy/jieba/blob/master/extra_dict/stop_words.txt 用法示例：https://github.com/fxsjy/jieba/blob/master/test/extract_tags_stop_words.py关键词一并返回关键词权重值示例 用法示例：https://github.com/fxsjy/jieba/blob/master/test/extract_tags_with_weight.py 基于 TextRank 算法的关键词抽取 jieba.analyse.textrank(sentence, topK=20, withWeight=False, allowPOS=(‘ns’, ‘n’, ‘vn’, ‘v’)) 直接使用，接口相同，注意默认过滤词性。 jieba.analyse.TextRank() 新建自定义 TextRank 实例算法论文： TextRank: Bringing Order into Texts基本思想: 将待抽取关键词的文本进行分词 以固定窗口大小(默认为5，通过span属性调整)，词之间的共现关系，构建图 计算图中节点的PageRank，注意是无向带权图使用示例:见 test/demo.py 4、词性标注 jieba.posseg.POSTokenizer(tokenizer=None) 新建自定义分词器，tokenizer 参数可指定内部使用的 jieba.Tokenizer 分词器。jieba.posseg.dt 为默认词性标注分词器。 标注句子分词后每个词的词性，采用和 ictclas 兼容的标记法。 用法示例123456789&gt;&gt;&gt; import jieba.posseg as pseg&gt;&gt;&gt; words = pseg.cut(&quot;我爱北京天安门&quot;)&gt;&gt;&gt; for word, flag in words:... print(&apos;%s %s&apos; % (word, flag))...我 r爱 v北京 ns天安门 ns 5、并行分词 原理：将目标文本按行分隔后，把各行文本分配到多个 Python 进程并行分词，然后归并结果，从而获得分词速度的可观提升 基于 python 自带的 multiprocessing 模块，目前暂不支持 Windows 用法： jieba.enable_parallel(4) # 开启并行分词模式，参数为并行进程数 jieba.disable_parallel() # 关闭并行分词模式 例子：https://github.com/fxsjy/jieba/blob/master/test/parallel/test_file.py 实验结果：在 4 核 3.4GHz Linux 机器上，对金庸全集进行精确分词，获得了 1MB/s 的速度，是单进程版的 3.3 倍。 注意：并行分词仅支持默认分词器 jieba.dt 和 jieba.posseg.dt。 6、Tokenize：返回词语在原文的起止位置 注意，输入参数只接受 unicode 默认模式123result = jieba.tokenize(u'永和服装饰品有限公司')for tk in result: print("word %s\t\t start: %d \t\t end:%d" % (tk[0],tk[1],tk[2])) 1234word 永和 start: 0 end:2word 服装 start: 2 end:4word 饰品 start: 4 end:6word 有限公司 start: 6 end:10 搜索模式123result = jieba.tokenize(u'永和服装饰品有限公司', mode='search')for tk in result: print("word %s\t\t start: %d \t\t end:%d" % (tk[0],tk[1],tk[2])) 123456word 永和 start: 0 end:2word 服装 start: 2 end:4word 饰品 start: 4 end:6word 有限 start: 6 end:8word 公司 start: 8 end:10word 有限公司 start: 6 end:10 7、ChineseAnalyzer for Whoosh 搜索引擎 引用： from jieba.analyse import ChineseAnalyzer 用法示例：https://github.com/fxsjy/jieba/blob/master/test/test_whoosh.py 8、命令行分词12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455使用示例：`python -m jieba news.txt &gt; cut_result.txt`命令行选项（翻译）： 使用: python -m jieba [options] filename 结巴命令行界面。 固定参数: filename 输入文件 可选参数: -h, --help 显示此帮助信息并退出 -d [DELIM], --delimiter [DELIM] 使用 DELIM 分隔词语，而不是用默认的&apos; / &apos;。 若不指定 DELIM，则使用一个空格分隔。 -p [DELIM], --pos [DELIM] 启用词性标注；如果指定 DELIM，词语和词性之间 用它分隔，否则用 _ 分隔 -D DICT, --dict DICT 使用 DICT 代替默认词典 -u USER_DICT, --user-dict USER_DICT 使用 USER_DICT 作为附加词典，与默认词典或自定义词典配合使用 -a, --cut-all 全模式分词（不支持词性标注） -n, --no-hmm 不使用隐含马尔可夫模型 -q, --quiet 不输出载入信息到 STDERR -V, --version 显示版本信息并退出 如果没有指定文件名，则使用标准输入。`--help` 选项输出： $&gt; python -m jieba --help Jieba command line interface. positional arguments: filename input file optional arguments: -h, --help show this help message and exit -d [DELIM], --delimiter [DELIM] use DELIM instead of &apos; / &apos; for word delimiter; or a space if it is used without DELIM -p [DELIM], --pos [DELIM] enable POS tagging; if DELIM is specified, use DELIM instead of &apos;_&apos; for POS delimiter -D DICT, --dict DICT use DICT as dictionary -u USER_DICT, --user-dict USER_DICT use USER_DICT together with the default dictionary or DICT (if specified) -a, --cut-all full pattern cutting (ignored with POS tagging) -n, --no-hmm don&apos;t use the Hidden Markov Model -q, --quiet don&apos;t print loading messages to stderr -V, --version show program&apos;s version number and exit If no filename specified, use STDIN instead. 延迟加载机制jieba 采用延迟加载，import jieba 和 jieba.Tokenizer() 不会立即触发词典的加载，一旦有必要才开始加载词典构建前缀字典。如果你想手工初始 jieba，也可以手动初始化。12import jiebajieba.initialize() # 手动初始化（可选） 在 0.28 之前的版本是不能指定主词典的路径的，有了延迟加载机制后，你可以改变主词典的路径:1jieba.set_dictionary(&apos;data/dict.txt.big&apos;) 例子： https://github.com/fxsjy/jieba/blob/master/test/test_change_dictpath.py 其他词典 占用内存较小的词典文件https://github.com/fxsjy/jieba/raw/master/extra_dict/dict.txt.small 支持繁体分词更好的词典文件https://github.com/fxsjy/jieba/raw/master/extra_dict/dict.txt.big下载你所需要的词典，然后覆盖 jieba/dict.txt 即可；或者用 jieba.set_dictionary(&#39;data/dict.txt.big&#39;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[logging 模块]]></title>
      <url>%2F2017%2F03%2F12%2Fpython_logging%2F</url>
      <content type="text"><![CDATA[logging模块日志级别1 )、 Level: CRITICAL Numeric value: 502 )、 Level: ERROR Numeric value: 403 )、 Level: WARNING Numeric value: 304 )、 Level: INFO Numeric value: 205 )、 Level: DEBUG Numeric value: 106 )、 Level: NOTSET Numeric value: 0 http://www.cnblogs.com/dkblog/archive/2011/08/26/2155018.html http://blog.csdn.net/zyz511919766/article/details/25136485]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PyInstaller模块]]></title>
      <url>%2F2017%2F03%2F12%2Fpython_pyInstaller%2F</url>
      <content type="text"><![CDATA[使用PyInstaller1、直接打包：1pyInstaller yourapp.py 可以得到dsit和build文件，dist文件夹下的exe文件即为打包好的可执行文件，但是依赖许多dll。pyInstaller可以添加的指令： -w指令：直接发布的exe应用带命令行调试窗口，在指令内加入-w命令可以屏蔽-F指令：注意指令区分大小写。这里是大写。使用-F指令可以把应用打包成一个独立的exe文件，否则是一个带各种dll和依赖文件的文件夹 2、配置打包：可以打包相应的图片或者音乐资源等。 2.1 生成配置文件：1pyi-makespec yourapp.py 生成配置文件yourapp.spec，大致如下：这里datas即为所需要添加的文件，原本是空的list。第一个参数为文件的路径，第二个参数为打包好后将其放入打包文件的相对路径，根据你的程序自己修改。我程序的ico索引是在当前目录下查找，所以相对路径为&#39;.&#39;。 2.2 执行配置文件1pyInstaller yourapp.spec 即可。 相关的配置文件，参考官网：https://pythonhosted.org/PyInstaller/spec-files.html。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Latex]]></title>
      <url>%2F2017%2F03%2F12%2FLatex%2F</url>
      <content type="text"><![CDATA[基本符号1、公式开始嵌套在文本中，使用$，单独一行使用$$。或者，使用如下作为公式的输入：123\begin&#123;equation&#125;公式\end&#123;equation&#125; 2、希腊符号：$ \alpha $ : $ \alpha $$ \beta $ : $ \beta $$ \gamma $ : $\gamma $$ \delta $ : $\delta $$ \eta $ : $\eta $$ \zeta $ : $\zeta $$ \varepsilon $ : $\varepsilon $$ \epsilon $ : $\epsilon $$ \theta $ : $\theta $$ \vartheta $ : $\vartheta $$ \iota$ : $\iota$$ \kappa $ : $\kappa $$ \xi $ : $\xi $$ \nu $ : $\nu$$ \mu $ : $\mu $$ \lambda $ : $\lambda $$ \pi $ : $\pi $$ \varpi $ : $\varpi $$ \rho $ : $\rho $$ \varrho $ : $\varrho $$ \upsilon $ : $\upsilon $$ \tau $ : $\tau $$ \varsigma $ : $\varsigma $$ \sigma $ : $\sigma $$ \phi $ : $\phi $$ \varphi $ : $\varphi $$ \chi $ : $\chi $$ \psi $ : $\psi $$ \omega $ : $\omega $ 3、基本运算3.0 运算格式$ \frac{分子}{分母} $ : $\frac{分子}{分母}$$ \sum_{a}^{b} $ : $ \sum_{a}^{b} $$ \prod_{a}^{b} $ : $ \prod_{a}^{b} $$ \bigcap_{a}^{b} $ : $ \bigcap_{a}^{b} $$ \int_{a}^{b} $ : $ \int_{a}^{b} $$ _{a}^{b}\textrm{} $ : $ _{a}^{b}\textrm{} $$ \iint_{a}^{b} $ : $ \iint_{a}^{b} $$ \lim_{a} $ : $ \lim_{a} $$ \sqrt[a]{b} $ : $ \sqrt[a]{b} $$ \coprod_{a}^{b} $ : $ \coprod_{a}^{b} $$ \frac{\mathrm{d} }{\mathrm{d} x} $ : $ \frac{\mathrm{d} }{\mathrm{d} x} $ 3.1 比较运算$ \leq $ : $ \leq $$ \geq $ : $ \geq $$ \leqslant $ : $ \leqslant $$ \geqslant $ : $ \geqslant $$ \nless $ : $ \nless $$ \ngtr $ : $ \ngtr $$ \nleqslant $ : $ \nleqslant $$ \ngeqslant $ : $ \ngeqslant $$ \neq $ : $ \neq $$ \equiv $ : $ \equiv $$ \not\equiv $ : $ \not\equiv $$ \ll $ : $ \ll $$ \gg $ : $ \gg $$ \approx $ : $ \approx $$ \simeq $ : $ \simeq $$ \cong $ : $ \cong $ 3.2 集合运算$ \propto $ : $ \propto $$ \cap $ : $ \cap $$ \cup $ : $ \cup $$ \subset $ : $ \subset $$ \supset $ : $ \supset $$ \supseteq $ : $ \supseteq $$ \subseteq $ : $ \subseteq $$ \nsubseteq $ : $ \nsubseteq $$ \nsupseteq $ : $ \nsupseteq $$ \supseteqq $ : $ \supseteqq $$ \subseteqq $ : $ \subseteqq $$ \nsubseteq $ : $ \nsubseteq $$ \nsupseteqq $ : $ \nsupseteqq $$ \ni $ : $ \ni $$ \in $ : $ \in $$ \notin $ : $ \notin $ 3.3 普通运算$ \times $ : $ \times $$ \pm $ : $ \pm $$ \mp $ : $ \mp $ 3.4 集合符号$ \mathbb{P}$ : $ \mathbb{P}$$ \mathbb{N}$ : $ \mathbb{N}$$ \mathbb{Z}$ : $ \mathbb{Z}$$ \mathbb{I}$ : $ \mathbb{I}$$ \mathbb{Q}$ : $ \mathbb{Q}$$ \mathbb{R}$ : $ \mathbb{R}$$ \mathbb{C}$ : $ \mathbb{C}$ 3.5 其他运算$ \therefore $ : $ \therefore $$ \because $ : $ \because $$ \partial $ : $ \partial $$ \varnothing $ : $ \varnothing $$ \forall $ : $ \forall $$ \infty $ : $ \infty $$ \mho $ : $ \mho $ 3.6 变量$ \dot{a} $ : $ \dot{a} $$ \hat{a} $ : $ \hat{a} $$ \bar{a} $ : $ \bar{a} $$ \vec{a} $ : $ \vec{a} $$ \tilde{a} $ : $ \tilde{a} $ 3.7 箭头$ \leftrightharpoons $ : $ \leftrightharpoons $$ \Rightarrow $ : $ \Rightarrow $$ \Leftarrow $ : $ \Leftarrow $$ \leftrightarrow $ : $ \leftrightarrow $$ n \to $ : $ n \to $$ \xleftarrow[a]{b} $ : $ \xleftarrow[a]{b} $$ \xrightarrow[a]{b} $ : $ \xrightarrow[a]{b} $$ \overset{a}{\leftarrow} $ : $ \overset{a}{\leftarrow} $$ \overset{a}{\rightarrow} $ : $ \overset{a}{\rightarrow} $ 比较全的：http://matplotlib.org/1.5.1/users/mathtext.html#mathtext-tutorial]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Windows Win+R]]></title>
      <url>%2F2017%2F03%2F12%2Fwindows_win_R%2F</url>
      <content type="text"><![CDATA[msconfig 系统配置实用程序mspaint 画图板dxdiag 检查directx信息devmgmt.msc 设备管理器notepad 打开记事本netstat -an （tc）命令检查接口sysedit 系统配置编辑器secpol.msc 本地安全策略syskey 系统加密，一旦加密就不能解开，保护Windows xp系统的双重密码services.msc 本地服务设置sndvol32 音量控制程序taskmgr 任务管理器eventvwr 事件查看器eudcedit 造字程序explorer 打开资源管理器perfmon.msc 计算机性能监测程序regedit.exe 注册表regedt32 注册表编辑器rononce -p 15秒关机calc 启动计算器clipbrd 剪贴板查看器cleanmgr 垃圾整理osk 打开屏幕键盘logoff 注销命令]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux-tar]]></title>
      <url>%2F2017%2F03%2F12%2Flinux_tar%2F</url>
      <content type="text"><![CDATA[打包12# 将整个 /etc 目录下的文件全部打包成为 /tmp/etc.tar.gztar -zcvf /tmp/etc.tar.gz /etc 解压1tar -zxvf /tmp/etc.tar.gz 主选项： c 创建新的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。相当于打包。x 从档案文件中释放文件。相当于拆包。t 列出档案文件的内容，查看已经备份了哪些文件。特别注意，在参数的下达中， c/x/t 仅能存在一个！不可同时存在！因为不可能同时压缩与解压缩。 辅助选项： -z ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩或解压？ 一般格式为xx.tar.gz或xx. tgz-j ：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩或解压？一般格式为xx.tar.bz2-v ：压缩的过程中显示文件！这个常用-f ：使用档名，请留意，在 f 之后要立即接档名喔！不要再加其他参数！-p ：使用原文件的原来属性（属性不会依据使用者而变）–exclude FILE：在压缩的过程中，不要将 FILE 打包！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[统计排序]]></title>
      <url>%2F2017%2F02%2F24%2Fpython_problem_count%2F</url>
      <content type="text"><![CDATA[统计123from collections import CounterCounter(nodes_str) # 统计有多少Counter(Counter(nodes_str).values()) # 统计有多少的有多少 排序对于list和dict都可以12aa = &#123;&apos;a&apos;:1, &apos;b&apos;:3, &apos;c&apos;:2&#125;sorted(aa.items(), key=lambda x: x[1])]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[编码问题]]></title>
      <url>%2F2017%2F02%2F24%2Fpython_problem_deencode%2F</url>
      <content type="text"><![CDATA[Unicode编码问题处理问题一当遇见以下情况。123str1 = &apos;\u82f9\u679c&apos; # 这里没有u，当传入参数不是unicode的时候print str1 # 结果是 : \u82f9\u679cprint u&apos;\u82f9\u679c&apos; # 结果是 : 苹果 解决方法：1234str1 = &apos;\u82f9\u679c&apos;uni_result = str1.decode(&quot;unicode-escape&quot;)print uni_result# 结果是 : 苹果 问题二aa.text的结果如下12In[190]: aa.textOut[190]: u&apos;\xe4\xb8\x8a\xe6\xb5\xb7A\xe8\x82\xa1&apos; 使用utf-8编码时候，出问题。打印结果不对1234In[191]: aa.text.encode(&apos;utf-8&apos;)Out[191]: &apos;\xc3\xa4\xc2\xb8\xc2\x8a\xc3\xa6\xc2\xb5\xc2\xb7A\xc3\xa8\xc2\x82\xc2\xa1&apos;In[192]: print aa.text.encode(&apos;utf-8&apos;)ä¸æµ·Aè¡ 可以使用1234In[193]: aa.text.encode(&apos;raw_unicode_escape&apos;)Out[193]: &apos;\xe4\xb8\x8a\xe6\xb5\xb7A\xe8\x82\xa1&apos;In[194]: print aa.text.encode(&apos;raw_unicode_escape&apos;)上海A股 或者使用123bb = eval(repr(aa.text).lstrip(&apos;u&apos;))print bb上海A股 问题三gb18030 - gbk - gb2312 相关阅读：【整理】Python中字符编码的总结和对比：Python 2.x的str和unicode vs Python 3.x的bytes和str ： http://www.crifan.com/summary_python_string_encoding_decoding_difference_and_comparation_python_2_x_str_unicode_vs_python_3_x_bytes_str/【总结】Python 2.x中常见字符编码和解码方面的错误及其解决办法 ： http://www.crifan.com/summary_python_2_x_common_string_encode_decode_error_reason_and_solution/其他的讲解：http://www2.imm.dtu.dk/pubdb/views/edoc_download.php/6095/pdf]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[time 模块 时间格式]]></title>
      <url>%2F2017%2F02%2F24%2Fpython_time%2F</url>
      <content type="text"><![CDATA[1、sleep(seconds)线程推迟指定的时间运行，单位为秒1time.sleep(10) 2、ctime(seconds) -&gt; string将一个时间戳(默认为当前时间)转换成一个时间字符串12time.ctime()&gt;&gt; &apos;Tue Nov 29 17:51:02 2016&apos; 3、localtime([seconds]) -&gt; (tm_year,tm_mon,tm_day,tm_hour,tm_min,tm_sec,tm_wday,tm_yday,tm_isdst)将一个时间戳转换成一个当前时区的struct_time，如果seconds参数未输入，则以当前时间为转换标准12time.localtime(time.time())&gt;&gt; time.struct_time(tm_year=2016, tm_mon=11, tm_mday=29, tm_hour=17, tm_min=52, tm_sec=14, tm_wday=1, tm_yday=334, tm_isdst=0) 4、strftime(format[, tuple]) -&gt; string将指定的struct_time(默认为当前时间)，根据指定的格式化字符串输出12time.strftime(&apos;%Y-%m-%d_%H-%M-%S&apos;,time.localtime())&gt;&gt; &apos;2016-11-29_17-57-51&apos; python中时间日期格式化符号： %y 两位数的年份表示（00-99） %Y 四位数的年份表示（000-9999） %m 月份（01-12） %d 月内中的一天（0-31） %H 24小时制小时数（0-23） %I 12小时制小时数（01-12） %M 分钟数（00=59） %S 秒（00-59） %a 本地简化星期名称 %A 本地完整星期名称 %b 本地简化的月份名称 %B 本地完整的月份名称 %c 本地相应的日期表示和时间表示 %j 年内的一天（001-366） %p 本地A.M.或P.M.的等价符 %U 一年中的星期数（00-53）星期天为星期的开始 %w 星期（0-6），星期天为星期的开始 %W 一年中的星期数（00-53）星期一为星期的开始 %x 本地相应的日期表示 %X 本地相应的时间表示 %Z 当前时区的名称 %% %号本身 5、strptime(string, format) -&gt; struct_time将时间字符串根据指定的格式化符转换成数组形式的时间 6、性能时间测试12345678910111213import timedef printruntime(t1): &apos;&apos;&apos; 性能测试，运行时间 &apos;&apos;&apos; d = time.time() - t1 min_d = np.floor(d / 60) sec_d = d % 60 hor_d = np.floor(min_d / 60) if hor_d &gt; 0: print &apos;Run Time is : &#123;2&#125; hours &#123;0&#125; min &#123;1:.4f&#125; s&apos;.format(min_d, sec_d, hor_d) else: print &apos;Run Time is : &#123;0&#125; min &#123;1:.4f&#125; s&apos;.format(min_d, sec_d)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[pycharm的git上传]]></title>
      <url>%2F2017%2F02%2F16%2Fgit_pycharm%2F</url>
      <content type="text"><![CDATA[git上传问题当在pycharm中使用git上传时候。 可能会出现以下问题： fatal: Authentication failed for ‘https://github.com/longgb246/pythonstudy.git/‘ 解决方法一：有的情况，如网上所说，重新执行Git config命令配置用户名和邮箱即可：12git config -–global user.name &quot;xxx&quot; git config –-global user.email &quot;xxx@xxx.com&quot; 解决方法二：更新pycharm中git的指定： 更新到最新的即可使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git配置]]></title>
      <url>%2F2017%2F02%2F16%2Fgit_config%2F</url>
      <content type="text"><![CDATA[使用git-bash：到网站下载即可：https://git-scm.com/downloads下载windows版本的就可以。 设置用户：12git config -–global user.name &quot;xxx&quot; git config –-global user.email &quot;xxx@xxx.com&quot; 其中查看已有的git配置，命令为：1git config -l git的lg配置1git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot; 效果如下： 1alias.lg=log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit 配置显示比较炫酷，图像如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Seaborn-05-Pairplot多变量图]]></title>
      <url>%2F2017%2F02%2F15%2Fpython_seaborn_05%2F</url>
      <content type="text"><![CDATA[12345#-*- coding:utf-8 -*-from __future__ import divisionimport numpy as npimport matplotlib.pyplot as pltimport seaborn as sns seaborn.pairplot(data, hue=None, hue_order=None, palette=None, vars=None, x_vars=None, y_vars=None, kind=’scatter’, diag_kind=’hist’, markers=None, size=2.5, aspect=1, dropna=True, plot_kws=None, diag_kws=None, grid_kws=None)¶数据指定： vars : 与data使用，否则使用data的全部变量。参数类型：numeric类型的变量list。{x, y}_vars : 与data使用，否则使用data的全部变量。参数类型：numeric类型的变量list。dropna : 是否剔除缺失值。参数类型：boolean, optional 特殊参数： kind : {‘scatter’, ‘reg’}, optional Kind of plot for the non-identity relationships.diag_kind : {‘hist’, ‘kde’}, optional。Kind of plot for the diagonal subplots. 基本参数： size : 默认 6，图的尺度大小（正方形）。参数类型：numerichue : 使用指定变量为分类变量画图。参数类型：string (变量名)hue_order : list of strings Order for the levels of the hue variable in the palettepalette : 调色板颜色markers : 使用不同的形状。参数类型：listaspect : scalar, optional。Aspect * size gives the width (in inches) of each facet.{plot, diag, grid}_kws : 指定其他参数。参数类型：dicts 返回： PairGrid 对象 1、散点图123sns.set(style=&quot;ticks&quot;, color_codes=True)iris = sns.load_dataset(&quot;iris&quot;)g = sns.pairplot(iris) 2、指定分类变量的，散点图1g2 = sns.pairplot(iris, hue=&quot;species&quot;) 使用调色板1g3 = sns.pairplot(iris, hue=&quot;species&quot;, palette=&quot;husl&quot;) 使用不同的形状1g4 = sns.pairplot(iris, hue=&quot;species&quot;, markers=[&quot;o&quot;, &quot;s&quot;, &quot;D&quot;]) 3、改变对角图使用 KDE1g5 = sns.pairplot(iris, diag_kind=&quot;kde&quot;) 使用回归1g6 = sns.pairplot(iris, kind=&quot;reg&quot;) 4、改变点形状，使用参数，使用 edgecolor123g7 = sns.pairplot(iris, diag_kind=&quot;kde&quot;, markers=&quot;+&quot;, plot_kws=dict(s=50, edgecolor=&quot;b&quot;, linewidth=1), diag_kws=dict(shade=True))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Seaborn-04-Jointplot两变量图]]></title>
      <url>%2F2017%2F02%2F15%2Fpython_seaborn_04%2F</url>
      <content type="text"><![CDATA[1234#-*- coding:utf-8 -*-import numpy as npimport matplotlib.pyplot as pltimport seaborn as sns 绿色：#6AB27B土色：#a27712浅紫色：#8172B2蓝色：#4C72B0红色：#C44E52 用于2个变量的画图1、基本参数seaborn.jointplot(x, y, data=None, kind=’scatter’, stat_func=, color=None, size=6, ratio=5, space=0.2, dropna=True, xlim=None, ylim=None, joint_kws=None, marginal_kws=None, annot_kws=None, **kwargs)特殊参数： kind : { “scatter” | “reg” | “resid” | “kde” | “hex” } 基本： color : 颜色。参数类型： matplotlib color size : 默认 6，图的尺度大小（正方形）。参数类型：numeric ratio : 中心图与侧边图的比例，越大、中心图占比越大。参数类型：numeric space : 中心图与侧边图的间隔大小。参数类型：numeric s : 点的大小。参数类型：numeric linewidth : 线的宽度。参数类型：numeric edgecolor : 点的边界颜色，默认无色，可以重叠。”w”为白色。参数类型：matplotlib color {x, y}lim : x、y轴的范围。参数类型：two-tuples {joint, marginal, annot}_kws : dicts Additional keyword arguments for the plot components.marginal_kws : 侧边图的信息。例如：dict(bins=15, rug=True)annot_kws : 注释的信息。例如：dict(stat=”r”) 返回： JointGrid 对象 2、散点图123tips = sns.load_dataset(&quot;tips&quot;)g = sns.jointplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, data=tips)g2 = sns.jointplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, data=tips, kind=&quot;scatter&quot;) 3、回归图1g3 = sns.jointplot(&quot;total_bill&quot;, &quot;tip&quot;, data=tips, kind=&quot;reg&quot;) 4、六角图1g4 = sns.jointplot(&quot;total_bill&quot;, &quot;tip&quot;, data=tips, kind=&quot;hex&quot;) 5、KDE 图1g5 = sns.jointplot(&quot;total_bill&quot;, &quot;tip&quot;, data=tips, kind=&quot;kde&quot;, space=0, color=&quot;#6AB27B&quot;) 6、分类变量与连续变量的图1g6 = sns.jointplot(&quot;size&quot;, &quot;total_bill&quot;, data=tips, color=&quot;#8172B2&quot;) 7、图相交：散点图+KDE 图123iris = sns.load_dataset(&quot;iris&quot;)g7 = (sns.jointplot(&quot;sepal_length&quot;, &quot;sepal_width&quot;, data=iris, color=&quot;k&quot;) .plot_joint(sns.kdeplot, zorder=0, n_levels=6)) 8、使用参数的画图12g8 = sns.jointplot(&quot;petal_length&quot;, &quot;sepal_length&quot;, data=iris, marginal_kws=dict(bins=15, rug=True), annot_kws=dict(stat=&quot;r&quot;), s=40, edgecolor=&quot;w&quot;, linewidth=1)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Seaborn-03-数据分布图]]></title>
      <url>%2F2017%2F02%2F15%2Fpython_seaborn_03%2F</url>
      <content type="text"><![CDATA[基本1234567#-*- coding:utf-8 -*-from __future__ import divisionimport numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom scipy import stats, integrateimport seaborn as sns 1、快速查看分布distplot123x = np.random.randint(0,10,100)sns.distplot(x, color=&quot;b&quot;, bins=10, rug=True)sns.distplot(x, hist=False) 2、画单变量图12345678910111213x = np.random.normal(0, 1, size=30)bandwidth = 1.06 * x.std() * x.size ** (-1 / 5.) # 带宽计算公式support = np.linspace(-4, 4, 200)kernels = []for x_i in x: kernel = stats.norm(x_i, bandwidth).pdf(support) kernels.append(kernel) plt.plot(support, kernel, color=&quot;#C55458&quot;)sns.rugplot(x, color=&quot;.2&quot;, linewidth=3)density = np.sum(kernels, axis=0)density /= integrate.trapz(density, support)plt.plot(support, density) 1sns.kdeplot(x, shade=True) 1234sns.kdeplot(x)sns.kdeplot(x, bw=.2, label=&quot;bw: 0.2&quot;)sns.kdeplot(x, bw=2, label=&quot;bw: 2&quot;)plt.legend() 12345x = np.random.gamma(6, size=200)sns.distplot(x)sns.distplot(x, label=&apos;kde&apos;, hist=False)sns.distplot(x, kde=False, fit=stats.gamma, label=&apos;fit-gamma&apos;, hist=False)plt.legend() 3、画二元变量分布图123mean, cov = [0, 1], [[1, .5], [.5, 1]]data = np.random.multivariate_normal(mean, cov, 200)df = pd.DataFrame(data, columns=[&quot;x&quot;, &quot;y&quot;]) （1）散点图1sns.jointplot(x=&quot;x&quot;, y=&quot;y&quot;, data=df, stat_func=stats.pearsonr) （2）六边图1234data2 = np.random.multivariate_normal(mean, cov, 1000)df2 = pd.DataFrame(data2, columns=[&quot;x&quot;, &quot;y&quot;])with sns.axes_style(&quot;white&quot;): sns.jointplot(x=df2[&quot;x&quot;], y=df2[&quot;y&quot;], kind=&quot;hex&quot;, color=&quot;k&quot;) （3）相交的 KDE 图1sns.jointplot(x=&quot;x&quot;, y=&quot;y&quot;, data=df2, kind=&quot;kde&quot;) （4）地毯图的 KDE 图1234f, ax = plt.subplots(figsize=(6, 6))sns.kdeplot(df2.x, df2.y, ax=ax)sns.rugplot(df2.x, color=&quot;#55A868&quot;, ax=ax)sns.rugplot(df2.y, vertical=True, ax=ax, color=&quot;#4C72B0&quot;) （5）星云图123f2, ax = plt.subplots(figsize=(6, 6))cmap = sns.cubehelix_palette(as_cmap=True, dark=0, light=1, reverse=True)sns.kdeplot(df2.x, df2.y, cmap=cmap, n_levels=60, shade=True) （6）加入+图1234g = sns.jointplot(x=&quot;x&quot;, y=&quot;y&quot;, data=df, kind=&quot;kde&quot;, color=&quot;#988CBE&quot;)g.plot_joint(plt.scatter, c=&quot;w&quot;, s=30, linewidth=1, marker=&quot;+&quot;)g.ax_joint.collections[0].set_alpha(0)g.set_axis_labels(&quot;$X$&quot;, &quot;$Y$&quot;) （7）画出两两变量散点图12iris = sns.load_dataset(&quot;iris&quot;)sns.pairplot(iris) （8）画联合核函数123g = sns.PairGrid(iris)g.map_diag(sns.kdeplot)g.map_offdiag(sns.kdeplot, cmap=&quot;Blues_d&quot;, n_levels=6)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Seaborn-02-颜色板控制]]></title>
      <url>%2F2017%2F02%2F15%2Fpython_seaborn_02%2F</url>
      <content type="text"><![CDATA[基本123456#-*- coding:utf-8 -*-from __future__ import divisionimport numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport seaborn as sns 1、定性调色板 Qualitative默认的定性调色板：deep, muted, pastel, bright, dark, colorblind.12current_palette = sns.color_palette()sns.palplot(current_palette) 12current_palette = sns.color_palette(&quot;pastel&quot;)sns.palplot(current_palette) 2、使用环形调色板画出均匀色带的颜色（改变颜色，但是保持色彩的亮度和饱和度）hls_palette : h(hue)l(lightness)s(saturation)，均在0-1之间12sns.palplot(sns.hls_palette(8, l=.3, s=.8))sns.palplot(sns.husl_palette(8, l=.3, s=.8)) 3、自定义一个RGB颜色带12flatui = [&quot;#9b59b6&quot;, &quot;#3498db&quot;, &quot;#95a5a6&quot;, &quot;#e74c3c&quot;, &quot;#34495e&quot;, &quot;#2ecc71&quot;]sns.palplot(sns.color_palette(flatui)) 4、序列颜色 Sequentialcubehelix_palette最好：start0~3,rot-1~112sns.palplot(sns.cubehelix_palette(8, start=.5, rot=-.75))sns.palplot(sns.cubehelix_palette(8, start=1.2, rot=.01)) 12sns.palplot(sns.cubehelix_palette(8, start=2, rot=0, dark=0, light=.95, reverse=True))sns.palplot(sns.cubehelix_palette(8, start=2, rot=0.05, reverse=True)) 123x, y = np.random.multivariate_normal([0, 0], [[1, -.5], [-.5, 1]], size=300).Tcmap = sns.cubehelix_palette(light=1, as_cmap=True)sns.kdeplot(x, y, cmap=cmap, shade=True) light_palette、dark_palette 两种颜色调，渐亮、渐暗12sns.palplot(sns.light_palette(&quot;green&quot;))sns.palplot(sns.light_palette(&quot;#000000&quot;)) 12345sns.palplot(sns.dark_palette(&quot;purple&quot;))sns.palplot(sns.dark_palette(&quot;#a27712&quot;))pal = sns.dark_palette(&quot;palegreen&quot;, as_cmap=True)sns.kdeplot(x, y, cmap=pal) 5、对称色调 diverging_palette12sns.palplot(sns.diverging_palette(145, 280, s=85, l=25, n=7))sns.palplot(sns.diverging_palette(10, 220, sep=80, n=7)) 1sns.palplot(sns.diverging_palette(255, 133, l=60, n=7, center=&quot;dark&quot;)) 6、色调画图1234567def sinplot(flip=1): x = np.linspace(0, 14, 100) for i in range(1, 7): plt.plot(x, np.sin(x + i * .5) * (7 - i) * flip)sns.set_palette(&quot;husl&quot;)sinplot() 12with sns.color_palette(&quot;PuBuGn_d&quot;): sinplot() 12with sns.cubehelix_palette(8, start=1.2, rot=.01): sinplot()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Seaborn-01-图控制]]></title>
      <url>%2F2017%2F02%2F15%2Fpython_seaborn_01%2F</url>
      <content type="text"><![CDATA[基本1234#-*- coding:utf-8 -*-import numpy as npimport matplotlib as mplimport matplotlib.pyplot as plt 1、引入 seaborn 风格12345def sinplot(flip=1): x = np.linspace(0, 14, 100) for i in range(1, 7): plt.plot(x, np.sin(x + i * .5) * (7 - i) * flip)sinplot() 12import seaborn as snssinplot() 2、预设主题：axes_style() 和 set_style()darkgrid, whitegrid, dark, white, ticks，默认的是 darkgrid123sns.set_style(&quot;whitegrid&quot;)data = np.random.normal(size=(20, 6)) + np.arange(6) / 2sns.boxplot(data=data) # 箱型线 12sns.set_style(&quot;dark&quot;)sinplot() 12sns.set_style(&quot;white&quot;)sinplot() 12sns.set_style(&quot;ticks&quot;)sinplot() 3、移除上框 despine()12345sinplot()sns.despine() # 默认移除上边框和右边框， despine(top=True, right=True, left=False, bottom = False)f, ax = plt.subplots()sns.violinplot(data=data)sns.despine(offset=10, trim=True) # 坐标轴分离 4、暂时风格 axes_style() + with12345with sns.axes_style(&quot;darkgrid&quot;): plt.subplot(211) sinplot()plt.subplot(212)sinplot(-1) 5、自定义风格12345sns.axes_style() # 查看现有风格sns.set_style(&quot;darkgrid&quot;, &#123;&quot;axes.facecolor&quot;: &quot;.9&quot;&#125;)sinplot()sns.set_context(&quot;notebook&quot;, font_scale=1.5, rc=&#123;&quot;lines.linewidth&quot;: 2.5&#125;)sinplot()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Pandas-office-10分钟开始]]></title>
      <url>%2F2017%2F02%2F15%2Fpython_pandas_01%2F</url>
      <content type="text"><![CDATA[基本1234# -*- coding:utf-8 -*-import numpy as npimport pandas as pdimport matplotlib.pyplot as plt 1、创建数据框1234dates = pd.date_range(&apos;20130101&apos;, periods=6)df = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=list(&apos;ABCD&apos;))left = pd.DataFrame(&#123;&apos;key&apos;: [&apos;foo&apos;, &apos;foo&apos;], &apos;lval&apos;: [1, 2]&#125;)right = pd.DataFrame(&#123;&apos;key&apos;: [&apos;foo&apos;, &apos;foo&apos;], &apos;rval&apos;: [4, 5]&#125;) 2、查看数据123456df.head()df.tail(3)df.describe()df.Tdf.sort_index(axis=1, ascending=False) # 按照行名、列名排列df.sort_values(by=&apos;B&apos;) 3、选择12# .loc()# .iloc() 4、缺失值1234df[&apos;E&apos;] = [1, 2, np.nan, 1, 2, np.nan]df.dropna(how=&apos;any&apos;)df.fillna(value=5)pd.isnull(df) 5、运用1df.apply(np.cumsum) 6、交并123456df = pd.DataFrame(np.random.randn(10, 4))pieces = [df[:3], df[3:7], df[7:]]pd.concat(pieces, axis=0)pd.concat([df, df], axis=1)pd.merge(left, right, on=&apos;key&apos;)left.merge(right, on=&apos;key&apos;) 7、groupby123456df = pd.DataFrame(&#123;&apos;A&apos;: [&apos;foo&apos;, &apos;bar&apos;, &apos;foo&apos;, &apos;bar&apos;, &apos;foo&apos;, &apos;bar&apos;, &apos;foo&apos;, &apos;foo&apos;], &apos;B&apos;: [&apos;one&apos;, &apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;two&apos;, &apos;two&apos;, &apos;one&apos;, &apos;three&apos;], &apos;C&apos;: np.random.randn(8), &apos;D&apos;: np.random.randn(8)&#125;)df.groupby(&apos;A&apos;).sum()df.groupby([&apos;A&apos;, &apos;B&apos;]).sum() 8、重组数据框123456789tuples = list(zip(*[[&apos;bar&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;baz&apos;, &apos;foo&apos;, &apos;foo&apos;, &apos;qux&apos;, &apos;qux&apos;], [&apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;, &apos;one&apos;, &apos;two&apos;]]))index = pd.MultiIndex.from_tuples(tuples, names=[&apos;first&apos;, &apos;second&apos;])df = pd.DataFrame(np.random.randn(8, 2), index=index, columns=[&apos;A&apos;, &apos;B&apos;])df2 = df[:4]stacked = df2.stack()stacked.unstack()stacked.unstack(1)stacked.unstack(0) Pivot Tables9、时间序列123456789rng = pd.date_range(&apos;1/1/2012&apos;, periods=100, freq=&apos;S&apos;) # 按秒进行rng2 = pd.date_range(&apos;3/6/2012 00:00&apos;, periods=5, freq=&apos;D&apos;) # 按天进行rng3 = pd.date_range(&apos;1/1/2012&apos;, periods=5, freq=&apos;M&apos;) # 按月进行，保留天数ts = pd.Series(np.random.randn(len(rng3)), index=rng3)ps = ts.to_period() # 天变为月，仅保留月数ps.to_timestamp() # 月变为天prng = pd.period_range(&apos;1990Q1&apos;, &apos;2000Q4&apos;, freq=&apos;Q-NOV&apos;) # 按季度进行ts = pd.Series(np.random.randn(len(prng)), prng)ts.index = (prng.asfreq(&apos;M&apos;, &apos;e&apos;) + 1).asfreq(&apos;H&apos;, &apos;s&apos;) + 9 # 季度转化为日期，指定时间 10、Categoricals 分类的使用12345df = pd.DataFrame(&#123;&quot;id&quot;: [1, 2, 3, 4, 5, 6], &quot;raw_grade&quot;: [&apos;a&apos;, &apos;b&apos;, &apos;b&apos;, &apos;a&apos;, &apos;a&apos;, &apos;e&apos;]&#125;)df[&quot;grade&quot;] = df[&quot;raw_grade&quot;].astype(&quot;category&quot;)df[&quot;grade&quot;].cat.categories = [&quot;very good&quot;, &quot;good&quot;, &quot;very bad&quot;]df[&quot;grade&quot;] = df[&quot;grade&quot;].cat.set_categories([&quot;very bad&quot;, &quot;bad&quot;, &quot;medium&quot;, &quot;good&quot;, &quot;very good&quot;])df.sort_values(by=&quot;grade&quot;)df.groupby(&quot;grade&quot;).size() 11、画图12345ts = pd.Series(np.random.randn(1000), index=pd.date_range(&apos;1/1/2000&apos;, periods=1000))ts = ts.cumsum()ts.plot()df = pd.DataFrame(np.random.randn(1000, 4), index=ts.index, columns=[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;])df = df.cumsum()df.plot(); plt.legend(loc=&apos;best&apos;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[聚类分析（2）：其他问题与算法]]></title>
      <url>%2F2017%2F02%2F15%2FML_ITDM_cluster_02%2F</url>
      <content type="text"><![CDATA[一、数据、簇、聚类算法（1）数据特性可能影响聚类分析的因素：高维性、规模、稀疏性、噪声和离群点、尺度 二、基于原型的聚类（1）模糊聚类1、模糊集合模糊集合论允许对象以 0 和 1 之间的某个隶属度隶属于一个集合。 2、模糊簇xi 为数据点集合，Ci 为模糊子集簇。 xi 的权值给定xi的所有权值之和为 1：$$ \sum_{j=1}^{k}w_{ij}=1$$ Ci 的限制每个 Ci 以非零权值至少包含一个点，但不以权值1包含所有点：$$ 0&lt; \sum_{i=1}^{m}w_{ij} &lt; m$$ 3、模糊 c 均值模糊 c 均值算法（FCM算法） 算法： 目标函数：计算SSE（误差平方和）：$$ SSE(C_{1},C_{2},…,C_{k})=\sum_{j=1}^{k}\sum_{i=1}^{m}w_{ij}^{p}dist(x_{i},c_{j})^{2}$$ cj 是第 j 个簇的质心。 初始化：随机初始化，但是限定求和为1. 计算质心：$$ c_{j}=\frac{\sum_{i=1}^{m}w_{ij}^{p}x_{i}}{\sum_{i=1}^{m}w_{ij}^{p}}$$ p为模糊权重，p=1时候，很想传统k均值，p越大，划分越模糊。一般选取p=2。 更新模糊伪划分当使用p时候，最小化SSE，可以推导出：$$ w_{ij}=\frac{(\frac{1}{dist(x_{i},c_{j})^{2}})^{\frac{1}{p-1}}}{\sum_{q=1}^{k}(\frac{1}{dist(x_{i},c_{q})^{2}})^{\frac{1}{p-1}}}$$ 当使用p=2的时候，公式得到简化：$$ w_{ij}=\frac{\frac{1}{dist(x_{i},c_{j})^{2}}}{\sum_{q=1}^{k}\frac{1}{dist(x_{i},c_{q})^{2}}}$$ 下面显示了一个模糊聚类的例子： 4、优点与缺点与K均值相同的有点和缺点。 （2）使用混合模型聚类1、混合模型 混合模型将数据看作从不同的概率分布得到的观测值集合。其数据产生过程为，给定几个分布（通常类型相同，参数不同）随机的选择一个分布并由它产生一个对象，重复该过程m次。 假定有 K 个分布和 m 个对象{x1,x2，…,xm}，\Theta 是参数的集合，则：$$ prob(x_{i}|\theta _{j})$$是第 i 个对象来自第 j 个分布的概率。由于权值受限，其和为 1 。对于对象 x 的概率由公式给出：$$ prob(x|\Theta)=\sum_{j=1}^{K}w_{j}p_{j}(x|\theta_{j})$$ 如果对象以独立的方式产生，则对象集的概率是每个对象 xi 的概率的乘积。$$ prob(\chi |\Theta)=\prod_{i=1}^{m}prob(x_{i}|\Theta)=\prod_{i=1}^{m}\sum_{j=1}^{K}w_{j}p_{j}(x_{i}|\theta_{j})$$ 混合高斯分布假定有两个高斯分布，有相同的标准差 2，均值分别为 -4 和 4 。还假定每个分布以等概率选取，即为 w1=w2=0.5。公式为：$$ prob(x|\Theta)=\frac{1}{2\sqrt{2\pi}}e^{-\frac{(x+4)^{2}}{8}}+\frac{1}{2\sqrt{2\pi}}e^{-\frac{(x-4)^{2}}{8}}$$ 则该模型产生的 20000 个点的直方图： 2、使用最大似然估计（MLE） 3、使用 EM 算法EM 算法步骤： 例子： 样本集上的EM： 4、EM算法在混合模型的优缺点缺点： 1、EM算法可能很慢。2、数据近似斜线性时候，不能很好处理。3、混合模型在有噪声和离群点时，可能有问题。 优点： 1、混合模型比K均值或模糊c均值更一般。2、可以发现不同大小和椭球状的簇。 （3）自组织映射自组织映射（SOFM或SOM）是一种基于神经网络观点的聚类和数据可视化技术。 [369-396=27]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[聚类分析（1）：基本概念和算法]]></title>
      <url>%2F2017%2F02%2F15%2FML_ITDM_cluster_01%2F</url>
      <content type="text"><![CDATA[一、概述（1）聚类分析 目标是，分组数据使得，组内的对象是相似的（相关的），不同组是不同的（不相关的）。 （2）聚类类型1、层次、划分层次聚类（嵌套聚类，hierarchial clustering）：聚类簇组织成一棵树，每一个结点是其子女的并。划分聚类（非嵌套聚类，partional clustering）：简单的将数据对象划分为不重叠的子集。 2、互斥、重叠、模糊互斥聚类（exclusive）：每个对象被指派到单独的单个簇。重叠聚类（overlapping）：一个对象可以同时属于多个簇。模糊聚类（fuzzy clustering）：概率聚类，每个对象以0-1之间的的权值隶属于一个类，但是每个对象的权值之和为1。 3、完全、部分完全聚类（complete clustering）：每个对象指派到一个类。部分聚类（partial clustering）：某些对象可以不属于明确定义的类。 （3）簇类型下面显示一些簇类型： 类型：明显分离、基于原型（中心簇）、基于图（连通）、基于密度、共同性质的（概念簇）。 二、K-均值（1）基本K-均值算法算法步骤： 目标函数：$$ SSE=\sum_{i=1}^{K}\sum_{x\in C_{i}}dist(c_{i},x)^{2}, c_{i}=\frac{1}{m_{i}}\sum_{x\in C_{i}}x$$ 上面的第3、4步骤试图最小化目标函数（SSE或者其他的），直到收敛。 常见的邻近度和目标函数组合： 初始质心：不同的初始质心会收敛到不同的结果。 随机初始质心：问题是，即使运行多次也不一定能得到好的分类。因为，一旦一个簇内有多个质心，该簇很可能被分裂。其他方法：先使用层次聚类，从中提取K个类，使用这K个类的质心作为初始质心。仅对：样本较小，K较小有效。 （2）K均值：附加问题处理空簇所有的点没有一个分配到一个质心。选择替补质心。 离群点离群点对于k-均值聚类有较大影响，应该删除。 后处理SSE增加簇： 分裂一个簇：选择SSE最大的分裂。引进一个新的质心：选择离所有质心最远的点。 减少簇： 拆散一个簇：删除簇的对应质心。簇中的点重新分配。合并两个簇：选择两个质心最接近的两个簇合并。 增量的更新质心给定一个目标函数，每步要零次或两次更新质心。可能产生次序依赖性问题，开销也稍微大一些。 （3）二分K均值思路： 为了得到 K 个簇，将所有点分裂成两个簇，从这些簇中，选取一个继续分裂，直到产生 K 个簇。 算法： 带分裂的簇选择方法有很多：最大的簇，最大SSE的簇等。 （4）优点与缺点优点：二分K均值，不太受初始值的影响。缺点：不能处理非球形簇、不同尺寸、不同密度的簇。 三、凝聚层次聚类（1）基本算法 （2）距离的度量：最短距离（min）、最长距离（max）、平均距离、ward和质心距离 （3）簇邻近度的Lance-Williams公式Lance-Williams公式：$$p(R,Q)=\alpha_{A}p(A,Q)+ \alpha_{B}p(B,Q)+\beta p(A,B)+\gamma |p(A,Q)-p(B,Q)|$$ A、B、Q合并得到R。p(. , .)是邻近度函数，以上表示它们为线性函数。下面是Lance-Williams公式鱼邻近度函数的对应： （4）层次聚类的问题 1、缺乏全局目标函数：避开了解决困难的组合优化问题，很难选择初始点的问题。2、合并是最终的：一旦合并就不能撤销。 四、DBSCAN基于密度聚类算法，寻找被低密度区域分离的高密度区域。 （1）传统密度：基于中心的方法 核心点（core point）：该点给定邻域的点个数超过用户给定阈值 MinPts（Eps为用户定义的距离）。A点。边界点（border point）：不是核心点，它落在某个核心点邻域。B点。噪声点（noise point）：即非核心点也非边界点。C点。 （2）DBSCAN算法思路： 任意两个足够近（Eps之内）的核心点将方到一个簇中。任何与核心点足够近的边界点放到相同簇中（如果边界点靠近不同簇的核心点，要解决平均问题）。噪声点丢弃。 算法步骤： 选择 Eps 和 MinPts使用 k-距离k-最近邻的距离，对于某个k，计算所有点的k-距离，以递增排序，则k-距离会在某个部分急剧变化（噪声点的k-距离很大）。选取k为MinPts，合适的距离为Eps。 下面为，使用Eps=10，MinPts=4的结果： （3）优点与缺点 优点：对抗噪音的能力很强，能够处理任意形状和大小的簇。缺点：DBSCAN当计算近邻的时候，开销很大。 五、簇评估（1）非监督簇评估：凝聚度、分离度$$ overallValidity=\sum_{i=1}^{K}w_{i}validity(C_{i})$$K个簇的有效性，为个体簇的有效性加权和，下面给出度量表： 1、基于图：凝聚度、分离度 proximity函数可以是相似度、相异度，或者是这些量的简单函数：$$ cohesion(C_{i})=\sum_{x\in C_{i},y\in C_{i}}proximity(x,y)$$$$ separation(C_{i},C_{j})=\sum_{x\in C_{i},y\in C_{j}}proximity(x,y)$$ 2、基于原型：凝聚度、分离度 ci是Ci的原型（质心），c是总体原型（质心）：$$ cohesion(C_{i})=\sum_{x\in C_{i}}proximity(x,c_{i})$$$$ separation(C_{i},C_{j})=proximity(c_{i},c_{j})$$$$ separation(C_{i})=proximity(c_{i},c)$$ 3、轮廓系数轮廓系数（silhouette coefficient）： 1、对于第 i 个对象，计算它到所在簇所有点的平均距离：ai2、对于第 i 个对象，计算它到不含它的其他簇所有对象的平均距离，找出最小的：bi3、对于第 i 个对象，轮廓系数为：$$s_{i}=\frac{(b_{i}-a_{i})}{max(a_{i},b_{i})}$$ （3）非监督簇评估：近邻矩阵 可以使用某个距离度量法来度量相似度，得到每个点的距离，汇总得到近邻矩阵。但是仅使用于小数据、抽样。 （4）簇个数 使用 SSE 和轮廓系数来判断，统计上的 SSE 的说明性更强，统计上不止这一个系数可以分类。 （5）聚类趋势度量空间中的点是否为随机分布的，使用Hopkins统计量：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关联分析（2）：高级概念]]></title>
      <url>%2F2017%2F02%2F15%2FML_ITDM_realation_02%2F</url>
      <content type="text"><![CDATA[一、处理分类属性依然使用虚拟变量。 （1）属性值有可能不频繁，可以分组处理，使得较小数据合并。（2）某些属性的频率出现比其他压高很多，出现冗余模式，可能需要剔除。 二、处理连续变量（1）基于离散化方法问题：区间宽度不好确定，计算开销比较大，提取许多冗余的规则。 （2）基于统计学方法[略] （3） 非离散化方法[略] 三、处理概念分层[略] 四、序列模式[略] 五、子图模式[略] 六、非频繁模式[略]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关联分析（1）：基本概念和算法]]></title>
      <url>%2F2017%2F02%2F15%2FML_ITDM_realation_01%2F</url>
      <content type="text"><![CDATA[一、基本概念（一）基本概念二元概念对于购物篮数据，使用二元变量表示。1表示购买，0表示没有购买。 项集和支持度计数事务：一行数据。k-项集：一个事务中，出现项。如：3-项集，{啤酒，尿布，牛奶} 支持度计数：$$\sigma (X)=|\left \{ t_{i}|X\subseteq t_{i},t_{i}\in T \right \}|$$ 如，上式中，项集{啤酒，尿布，牛奶}的支持度计数为2，因为只有2个事务同时包含3个项。 关联规则（association rule）关于 X、Y 的关联规则，支持度、置信度的定义如下：$$s(X\rightarrow Y)=\frac{\sigma (X\cup Y)}{N}$$$$s(X\rightarrow Y)=\frac{\sigma (X\cup Y)}{\sigma (X)}$$ 例如：X{牛奶，尿布}，Y{啤酒}，则并集{牛奶，尿布，啤酒}的支持度计数为2，N为事务总数5，所以支持度=2/5=0.4。X 的支持度=3，所以置信度为2/3=0.67。 支持度很低的规则可能只是偶然出现，低的支持度计数也是无意义的。支持度通常用于删去无意义的规则，置信度越高，表示Y在包含X的事务中出现的可能性较大。Y也可以用于估计在给定X的条件下的条件概率。 （二）关联规则挖掘 1、频繁项集产生：发现满足最小支持度阈值的所有项集，这些项是频繁项集。2、规则产生：从频繁项集中提取所有高置信度规则，这些规则是强规则。 （三）频繁项集的产生格结构（lattice structure）： 原始方法：遍历每个项集，使用项集与事务进行比较，计算每个项集的支持度计数。但是该方法的算法复杂度很高：O(NMw)。改进方法： 1、减少候选项的数目。先验原理，不计算支持度而删除某些候选项集。2、减少比较次数。更高级的数据结构。 先验原理 先验原理：如果一个项集是频繁的，则它的所有子集也一定是频繁的。相反的，如果一个项集是非频繁的，则它的所有超集也一定是非频繁的。支持度计数的反单调性：一个项集的支持度不会超过它的子集的支持度。 （四）Apriori 算法的频繁项集产生过程图： 算法的流程： 算法讲解：1、先定一个阈值k。2、候选项集为1-项集的，计算支持度，若支持度大于阈值，则保留；若小于则剔除。3、使用(k-1)-项集，产生k-项集。4、重复上面的步骤，直到无候选集（频繁集），结束。 1、Apriori 算法：12345678910k = 1F_(1) = &#123;1-项集 &gt;= min_c&#125;while true k = k + 1 Ck = apriori_gen(F_(k-1)) \\产生候选集 for c in Ck do \\事务 for t in T do if isin(t,c) dc = dc + 1 \\支持度计数 F_(k) = &#123;提取频繁k-项集^dc &gt;= min_c&#125; 2、Apriori_gen方法：F(k-1)*F(1)方法 F(k-1)*F(k-1)方法 原理：使用了字典序，例如：算法不会合并{啤酒，尿布}{尿布，牛奶}，因为如果{啤酒，尿布，牛奶}有效，则它应该由{啤酒，尿布}{啤酒，牛奶}合并。 支持度计数支持度计数在apriori_gen函数的候选项保留下来的之中计算。一种枚举方法是： 每项都以字典序排列，按照上面的枚举。 使用hash树进行支持度计数[略] 计算复杂度[略] 二、规则产生（1）基于置信度的剪枝定理 如果 X-&gt;Y-X 不满足置信度阈值，则X’-&gt;Y-X’ 的规则一定不满足置信度阈值，其中，X’ 是 X 的子集。 （2）Apriori 规则产生可以利用上面的定理进行剪枝，如左边的bcd-&gt;a不满足置信度阈值，则下面的都减去： 算法 三、频繁项集的紧凑表示（1）极大频繁项集 极大频繁项集（maximal frequent itemset）：它的直接超集都不是频繁的，频繁项集。 如上图，{ad}、{ace}、{bcde} 均是极大频繁项集。 （2）闭频繁项集 闭项集（closed itemset）：项集X是闭的，如果它的直接超集都不具有和它相同的支持度计数。 如上图，{b}{ad}都不是闭项集，而{bc}是闭项集。 闭频繁项集（closed frequent itemset）一个项集是闭频繁项集，它是闭的，并且它的支持度计数大于或等于最小支持度阈值。 计算闭频繁项集的支持度算法： 项集之间的关系： 四、产生频繁项集的其他方法[略] 五、FP增长算法[略] 六、关联模式的评估（1）兴趣度的客观度量支持度-置信度框架的局限性[略] 兴趣因子[略] 相关分析[略] IS度量[略] 1、其他客观度量度量分为对称和非对称： 对称：M(A-&gt;B)=M(B-&gt;A)。用于评价项集。非对称：M(A-&gt;B)!=M(B-&gt;A)。用于分析关联规则。 对称度量： 非对称度量： 2、客观度量的一致性上面提到的一系列的度量，不一定都是一致的，需要具体分析。 3、客观度量的性质[略][后略]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[分类（6）：不平衡和多分类问题]]></title>
      <url>%2F2017%2F02%2F15%2FML_ITDM_classfy_06%2F</url>
      <content type="text"><![CDATA[一、不平衡问题（1）不平衡数据例如：一个产品生产的不合格产品数量会远低于合格产品数量。信用卡欺诈的检测中，合法交易远远多于欺诈交易。这时候，准确率的度量会出现一些问题，因为她把每个类都看得同等重要。例如，1%的信用卡交易是欺诈行为，则预测每个交易都是合法的模型有99%的准确率，它也可能检测不到任何欺诈交易。 （2）混淆矩阵在不平衡数据中，稀有类比较有意义，对于二元分类，稀有类通常记为正类，而多数类被认为是负类。下面显示了混淆矩阵： 真正（true positive，TP）：++假正（false positive，FP）：-+真负（true negative，TN）：–假负（false negative，FN）：+- 真正率（true positive rate，TPR）或灵敏度（sensitivity）：$$ TPR=\frac{TP}{TP+FN}=\frac{(++)}{(++)+(+-)}$$真负率（true negative rate，TNR）或特指度（specificity）：$$TNR=\frac{TN}{TN+FP}=\frac{(–)}{(–)+(-+)}$$假正率（false positive rate，FPR）：$$FPR=\frac{FP}{TN+FP}=\frac{(+-)}{(–)+(-+)}$$假负率（false negative rate，FNR）：$$ FNR=\frac{FN}{FN+TP}=\frac{(-+)}{(-+)+(++)}$$精度（precision）：$$ p=\frac{TP}{TP+FP}=\frac{(++)}{(++)+(-+)}$$召回率（recall）即为真正率：$$r=\frac{(TP)}{(TP)+(FN)}=\frac{(++)}{(++)+(+-)}$$精度和召回率是很重要的度量量，称为 F1 统计量：$$ F_{1}=\frac{2rp}{r+p}=\frac{2\times TP}{2\times TP+FP+FN}=\frac{2}{\frac{1}{r}+\frac{1}{p}}$$F1 是召回率和精度的调和平均数，F1 趋近于它们之间的较小值，因此，一个高的 F1 确保精度和召回率都高。Fb 的公式：$$ F_{b}=\frac{(b^{2}+1)rp}{r+b^{2}p}=\frac{(b^{2}+1)}{\frac{1}{r}+\frac{b^{2}}{p}}$$低的 b 使得 Fb 更加接近精度，高的 b 使得 Fb 更加接近召回率。 （3）接受者操作曲线（ROC） 是真正率和假正率取折中的一种图形化方法。真正率为 y 轴，假正率为 x 轴。 ROC的几个关键点： （TPR=0,FPR=0）:把所有的都预测为负（TPR=1,FPR=1）:把所有的都预测为正（TPR=1,FPR=0）:理想模型。只要是正的，都预测为正。 一个好的分类器，尽量靠近左上角，随机猜想为对角线。 产生ROC曲线方法： （4）代价敏感学习模型 M 的代价：$$ C_{t}(M)=TP\times C(+,+)+FP\times C(-,+)+FN\times C(+,1)+FN\times C(-,-)$$ 如下是一个代价矩阵： 它可以把决策边界扩展： 对于代价矩阵，若 C(+,+)=C(-,-)=0 的情况，分类正确不需要代价，则： 求解可以得到决策边界。 基于抽样方法对于样本进行处理，假设有100个正样本和1000个负样本。不充分抽样（udersampling）：取和正样本一样数量的负样本，取100个负样本，形成训练集。过分抽样（oversampling）：将正样本复制，或者重复抽样，使得正样本的数量和负样本一样1000个。 二、多类问题 1、one-vs-rest 方法。将多类问题分解为 K 个二类问题，将属于$y_{i}$的归为正类，而其他类被分为负类，依次进行。2、one-vs-one 方法。它构建$\frac{K(K-1)}{2}$ 个二分类器，每一个分类器用来区分一对类 $(y_{i},y_{j})$ ，当为类 $(y_{i},y_{j})$ 建立分类器的时候，将不属于 $(y_{i},y_{j})$ 的样本忽略掉。 例子： 使用上述两种方法建模后，可能出现分类平局。另一种方法，将输出转变为概率估计，将实例给予高概率的类。 纠错输出编码纠错输出编码（error-correcting output coding，ECOC）：一种处理多分类更加鲁棒的方法，给予每个类一个代码字，对于每个可能预测错误的，选取距离代码字最近的那一类。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[分类（5）：组合分类器-随机森林]]></title>
      <url>%2F2017%2F02%2F15%2FML_ITDM_classfy_05%2F</url>
      <content type="text"><![CDATA[一、组合方法（1）组合分类器原理：考虑25个二元分类器，每一个分类误差a=0.35。组合分类器通过多数投票，如果基分类器是独立的，则仅当超过一半的基分类器都预测错误时，组合才会错误，则：$$ e_{ensemble}=\sum_{i=1}^{25}C_{25}^{i}a^{i}(1-a)^{25-i}=0.06$$ 可以看出，其远低于0.35。 （2）组合分类器与基分类器比较： 上图，虚线表示所有基分类器都一样，实线表示所有基分类器都独立。可以看出，当基分类器的错误率大于0.5（仅这个例子吗？）时候，组合分类器的性能不比基分类器的性能好。组合分类器的性能优于基分类器的条件： 1、基分类器应该是独立的。2、基分类器应当好于随机猜想。 （3）袋装（bagging）-自助法（bootstrap aggregating）袋装-自助法（bootstrap）：训练集是对于原数据集的有放回抽样，如果原始数据集N，可以证明，大小为N的自助样本大约包含原数据63.2%的记录。当N充分大的时候，1-（1-1/N）^(N) 概率逼近 1-e^(-1)=0.632。抽样 b 次，产生 b 个bootstrap样本，则，总准确率为（accs为包含所有样本计算的准确率）：$$ acc_{boot}=\frac{1}{b}\sum_{i=1}^{b}(0.632\times\varepsilon _{i}+0.368\times acc_{s})$$ 袋装算法：12345设 k 为自助样本的数目for i = 1 to k do 生成一个大小为 N 的自助样本 Dt 在自助样本 Dt 上训练一个基分类器 CiC*=argmax（Ci...） 袋装举例理解：下面的这个数据集，使用决策树，熵值来分裂，可以得到分裂点为：x&lt;=0.35 或 x&lt;=0.75，但是无论是哪个分类点，准确率都最多为70%。 使用袋装抽样： 使用简单的求和，取符号，可以发现，分类正确率为100%： 袋装评价： 1、通过降低基分类器的方差改善了泛化误差2、袋装的性能依赖于基分类器的稳定性。如果基分类器是不稳定的，袋装有助于降低训练数据的随机波动导致的误差；如果基分类器是稳定的，则组合分类器的误差主要由基分类器的偏倚引起，则这种情况下，袋装可能会降低分类器的性能。3、袋装中的数据是均概率被选中，所以对特定数据不敏感，对于噪音，不太受过拟合影响。 （4）提升（Boosting） 提升是一个迭代过程，自适应的改变样本的分布，使得基分类器聚焦在那些很难分类的样本上，提升每次给一个训练样本一个权值，在每一轮结束的时候自动地调整权值。 现在又很多提升算法，算法的差别在于： （1）每轮提升结束时如何更新训练样本权值（2）如何组合每个分类器的预测 AdaBoost在该算法中，基分类器 Ci 的重要性依赖于它的错误率，错误率的定义：$$ error_{i}=\frac{1}{N}\left[\sum_{j=1}^{N}w_{j}I(C_{i}(x_{j}\neq y_{j}))\right]$$对于I，为指示变量，错误个数的加权取平均，基分类器的重要度 \alpha 为：$$ \alpha_{i}=\frac{1}{2}ln\left(\frac{1-error_{i}}{error_{i}}\right)$$作出重要度 \alpha 关于 error 的图： 发现错误率接近 0 时候，重要度很大，接近 1 时候，重要度负向很大。Adaboost 的权值更新有以下给出，第 j 次迭代： Zj 是一个正规因子，用于确保：$$\sum_{i}w_{i}^{j+1}=1$$ AdaBoost算法： AdaBoost例子： 1、该组合分类器的训练误差呈指数递减，从而算法很快就会收敛。2、但是它倾向于那些被误分类的样本，所以提升技术很容易受到过拟合的影响。 二、随机森林（Random Forest）随机森林的过程图： 已经从理论上证明了，当树的数目足够大的时候，随机森林的泛化误差的上界收敛于下面表达式： 随机森林性质每棵决策树都使用一个从固定概率分布产生的随机向量。可以使用多种方法将随机向量合并到树中。 不同的随机森立方法： 1、Forest-RI。随机选择 F 个输入特征来对决策树的结点进行分裂，树之后完全增长不进行任何修剪，这有助于减少树的偏倚。之后用多数投票表决来组合预测。为了增加随机性，可以使用自助样本。2、Forest-RC。d 的数目太小的情况，需要增大特征空间，创建输入特征的线性组合。输入特征用区间[-1,1]的均匀分布产生的系数进行线性组合。3、对于每个结点，从 F 个最佳划分中随机选择一个，该方法也是比上面两个更花费时间。4、随机森林的分裂准确率与Adaboost相媲美，但它对噪声更加鲁棒，运行速度也比Adaboost快得多。 随机森林的一些参数选择通常选取特征数目为：$$ F=log_{2}^{d}+1$$d 为输入特征数。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[分类（4）：支持向量机（SVM）]]></title>
      <url>%2F2017%2F02%2F15%2FML_ITDM_classfy_04%2F</url>
      <content type="text"><![CDATA[一、基本概念SVM 寻找一个最大边缘超平面（maximal margin hyperplane），使得将数据分开，并且有最大的margin，泛化能力。 （1）结构风险最小化（structual risk minimization，SRM）线性分类器的边缘与泛化误差之间的关系，分类器的泛化误差在最坏的情况下：$$R\leqslant R_{e}+\varphi \left(\frac{h}{N},\frac{log(\eta )}{N}\right)$$$\varphi$是h的单调增函数，$1-\eta$表示概率。 （2）SVM线性分类器模型：$$ w\cdot x+b=0$$线性分类图：于是我们有：$$ w\cdot x_{s}+b=k,w\cdot x_{c}+b=k$$其中，k&gt;0，左边表示在决策边界的上面。k’&lt;0，右边表示在决策边界下面。如果我们标记一个类为+1，另一个类为-1，则有： 距离：$$ w(x_{1}-x_{2})=2\rightarrow d=\frac{2}{\left | w \right |},\left | w \right |=\sqrt{w_{1}^{2}+w_{2}^{2}+…+w_{k}^{2}}$$ （3）线性SVM：可分情况决策边界的参数上面的为+1，下面的为-1，则可以概括为：$$ y_{i}(w\cdot x_{i}+b)\geqslant 1,i=1,2,…,N$$最大化边缘，等价于最小化下面目标函数：$$f(w)=\frac{\left|w\right|^{2}}{2}$$目标函数是二次的，约束在w、b上是线性的，这是一个凸优化问题，通过拉格朗日乘子求解。$$L_{p}=\frac{1}{2}\left|w\right|^{2}-\sum_{i=1}^{N}\lambda _{i}(y_{i}\left(w\cdot x_{i}+b)-1\right)$$ Karuch-Kuhn-Tucher（KKT）：把不等式约束转换为等式约束，限制拉格朗日乘子非负。$$ \lambda_{i}\geqslant 1$$$$ \lambda_{i}[y_{i}(w\cdot x_{i}+b)-1]=0$$下面的等式，使得许多拉格朗日乘子都变为零。该约束表明，除非$y_{i}(w*x_{i}+b)=1$，否则拉格朗日乘子必须为零。那些$\lambda&gt;0$的训练实例在两个超平面上，称为支持向量，$lambda=0$的肯定不在超平面上。决策边界w、b仅仅依赖这些支持向量。此外，也可以使用对偶拉格朗日，使用二次规划求解。 SVM的例子： &lt;简书&gt;：我的心在滴血啊，写了一下午，你居然没有保存，网站页面设计的“保存中…”“已保存”就是个普通js吗？没有事务的吗？就修改文档的时候触发一下，然后也不判断是否联网，是否保存等。逗！！再不用简书。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[分类（3）：人工神经网络（ANN）]]></title>
      <url>%2F2017%2F02%2F15%2FML_ITDM_classfy_03%2F</url>
      <content type="text"><![CDATA[一、感知器下图为一个感知器，单个神经元。该感知器的算法： 二、多层人工神经网络（1）基本概念神经网络，这里先以前馈神经网络为介绍，每层为全连接，则对于2个神经元，参数为： （1）w权值，（2）b偏置，（3）delta 激活函数。 多层神经网络的结构图，以下为前馈神经网络的结构（2层）：常用的 delta 激活函数：基于梯度下降的权值更新：$$ w_{j}\leftarrow w_{j}-\lambda \frac{\partial E(w)}{\partial w_{j}}$$$\lambda$为学习率。 （2）反向传播（back-propagation）对于数据集，可以使用mini-batch，每次选取一部分，直到将数据使用完毕。每次每个数据包括两个阶段， 向前阶段和向后阶段。 向前阶段：通过初始权值、初始偏置和激活函数，每次更新隐藏层和输出层的值；向后阶段：通过权值更新法则，更新权值和偏置。直到数据使用完毕，或者，权值更新的差值小于某个阈值。 （3）神经网络特点 1、至少含有一个隐藏层的是一种普适近似（universal approximator），即可以用来近似任何目标函数。2、可以处理冗余特征，冗余特征的权值会非常小。3、梯度下降法会收敛到局部极小值，避免方法可以在权值更新公式上加上一个动量项（momentum term）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[分类（2）：k-最近邻、贝叶斯分类器]]></title>
      <url>%2F2017%2F02%2F15%2FML_ITDM_classfy_02%2F</url>
      <content type="text"><![CDATA[一、k-最近邻1、算法积极学习方法（eager learner）：通过训练样本建立模型。消极学习方法（lazy learner）：实例的学习，k-最近邻就属于这种。 k-最近邻算法：12345令k是最近邻数目，D是训练样例集合for z in 样例集合: 计算 z 和每个样例 (x,y) 的距离 d 选择离 z 前 k 个近距离的点，为集合 Dt z的标记 y 为 Dt 中类较多的 k-最近邻采用多数表决的方法，该算法对 k 敏感：$$y’=argmax_{v}\sum_{(x_{i},y_{i})\in D_{t}} I(v=y_{i})$$所以，需要降低 k 的影响，一种途径就是对距离的不同加权，如下，因为距离远的影响要弱一些，以距离平方的倒数为权值。$$y’=argmax_{v}\sum_{(x_{i},y_{i})\in D_{t}}w_{i}\times I(v=y_{i}),w_{i}=\frac{1}{d(x’,x_{i})^{2}}$$ 2、最近邻分类器特征： （1）实例的学习，不需要建模，但分类测试的开销很大。（2）当k比较小的时候，对噪声非常敏感。（3）可以生成任意决策边界。 二、贝叶斯分类器1、贝叶斯公式$$P(Y_{j}|X)=\frac{P(X|Y_{j})P(Y_{j})}{P(X)}=\frac{P(X|Y_{j})P(Y_{j})}{\sum_{i=1}^{n}P(X|Y_{i})P(Y_{i})}$$ 2、朴素贝叶斯（1）条件独立性：给定 Z，X 条件独立于 Y:$$P(X|Y,Z)=P(X|Z)$$则有：$$P(X,Y|Z)=\frac{P(Z,Y,X)}{P(Z)}=\frac{P(Z,Y,X)}{P(Y,Z)}\frac{P(Y,Z)}{P(Z)}=P(X|Y,Z)P(Y|Z)=P(X|Z)P(Y|Z)$$ （2）朴素贝叶斯分类器：$$P(Y|X)=\frac{P(X|Y)P(Y)}{P(X)}=\frac{P(X_{1},…,X_{d})P(Y)}{P(X)}=\frac{P(Y)\prod_{i=1}^{d}P(X_{i}|Y)}{P(X)}$$ （3）连续属性的条件概率：把每个连续属性离散化，用相应的区间去替代原来的属性，但若某一个区间的样本数目过少，不容易做出可靠的估计。 可以假设连续变量服从正态分布，Xi的概率等于：$$P(X_{i}=x_{i}|Y=y_{j})=\frac{1}{\sqrt{2\pi}\sigma_{ij}}e^{-\frac{(x_{i}-\mu_{ij})^{2}}{2\sigma_{ij}}}$$其中 $\mu$ 用样本均值估计， $\sigma$ 用样本方差估计。 （4）朴素贝叶斯举例：拖欠贷款为 Y 变量。测试记录X=（有房=否，婚姻状况=已婚，年收入=120K），求后验概率P（No|X）、P（Yes|X）。总的 Y 可以知道，P（Yes）=0.3，P（No）=0.7。则： P（X | No）=P（有房=否 | No）x P（婚姻状况=已婚 | No）x P（年收入=120K | No）=0.0024P（X | Yes）= P（有房=否 | Yes）x P（婚姻状况=已婚 | Yes）x P（年收入=120K | Yes）=0 因为P（No|X）&gt;P（Yes|X），所以该测试分类为No，不拖欠贷款。上例中，P（婚姻状况=已婚 | Yes）=0，可能会出现极端现象，为了防止出现0，朴素贝叶斯没法正确分类，可以使用 m 估计（m-estimate）：$$ P(x_{i}|y_{j})=\frac{n_{c}+mp}{n+m}$$$n$ 为 $y_{i}$ 的实例总数，$n_{c}$ 为 $y_{i}$ 中 $x_{i}$ 的实例数目，p 是用户指定，m 为等价样本大小的参数。上面的计算：P（婚姻状况=已婚 | Yes）=(0+3 x 1/3)/(3+3)=1/6，而不是0。 （4）朴素贝叶斯特征： 对于噪声点，朴素贝叶斯是健壮的。也可以处理属性值遗漏问题。无关属性，朴素贝叶斯是健壮的。对于相关属性，可能会降低分类性能。 3、贝叶斯置信网络（Bayesian belief networks，BBN）（1）模型表示：两个主要成分： 一个有向无环图（DAG），表示变量之间的关系；一个概率表，把各个结点和它的直接父节点关联起来。 性质1：条件独立贝叶斯网络中的一个结点，如果它的父母结点已知，则它条件独立于它的所有非后代结点。如图（b），给定C，A 条件独立于 B 和 D。除了网络拓扑结构要求的条件独立外，每个结点还关联一个概率表。 （1）如果结点 X 没有父母结点，则表中只包含先验概率P(X);（2）如果结点 X 只有一个父母结点 Y，则表中包含先验概率P(X | Y);（3）如果结点 X 有多个父母结点{Y1，Y2…，Yk}，则表中只包含先验概率P(X|Y1，Y2…，Yk); 下图是一个贝叶斯置信网络。 （2）建立模型：贝叶斯网络拓扑结构的生成算法：123456设T=（X1，X2，...Xd）表示变量的全序for j=1 to d do 令 XTj 表示 T 中第 j 个次序最高的变量 令A（XTj）=&#123;XT1，XT2，...XTj-1&#125; 表示排在 XTj 前面的变量的集合 从A（XTj）中去掉对 Xj 没有影响的变量（使用先验知识） 在 XTj 和 A（XTj） 中的剩余变量之间画弧 考虑到图5_03，经过循环后，得到的如下概率： P（D | E）化简为 P（D）P（HD | E,D）不能化简P（Hb | E,D,HD）化简为 P（Hb | D）P（CP | E,D,HD,Hb）化简为 P（CP | HD,Hb）P（BP | E,D,HD,Hb,CP）化简为 P（BP | HD） 上面的算法，保证了不会生成环。不同的变量排序会产生不同的拓扑结构，理论上需要 d！种排序才能找到最优的，开销很大。代替方法是把变量分成原因变量和结果变量，从原因到结果画弧。 （3）使用BNN进行推理：根据上面的贝叶斯置信网络图，有下面情况： （4）BNN的特点： 构造网络比较费时，但网络结构一旦确定下来，添加新变量就变得容易。很适合处理不完整数据，对有属性遗漏的可以通过概率或求积分来加以处理。数据和先验知识结合起来，该方法对于模型的过拟合问题是非常鲁棒的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[分类（1）：决策树与模型评估]]></title>
      <url>%2F2017%2F02%2F15%2FML_ITDM_classfy_01%2F</url>
      <content type="text"><![CDATA[一、如何建立决策树1、Hunt算法Hunt算法是许多决策树算法的基础，包括ID3、C4.5、CART。Hunt算法步骤： （1）如果Dt中所有数据都属于同一个类yt，则t是叶结点，用yt标记。（2）如果Dt中包含属于多个类的数据，则选择一个属性，将数据划分为较小子集。创建子女结点，将数据按属性放入子女结点中，然后递归调用该算法。 但是该算法对于大多数情况太苛刻了，需要附加： （1）没有可以选择的属性，则该结点为叶结点，类标号为父结点上较多数的类。（2）如果与Dt相关的数据均为同一个属性，则不可以继续划分，类标号为多数类。 2、属性划分（1）标称变量标称变量，二元划分和多路划分。CART只产生二元划分，考虑k个属性的二元划分有$2^{k-1}-1$种方法。 （2）有序变量有序变量，也可以是二元划分和多路划分，但是不能违背有序性。 3、属性划分标准选择最佳划分的度量是根据划分后子女结点的不纯度度量。不纯度越低（纯度越高！），划分效果越好。 （1）不纯度度量：$$Entropy(t)=-\sum_{i=0}^{c-1}p(i|t)log_{2}p(i|t),Entropy(t)\in[0,1]$$$$Gini(t)=1-\sum_{i=0}^{c-1}[p(i|t)]^{2},Gini(t)\in[0,0.5]$$$$ClassificationError(t)=1-max_{i}[p(i|t)],ClassificationError(t)\in[0,0.5]$$三个度量方法都是希望取值越小越好（越纯）。 （2）结点度量：为了确定测试结点效果，我们比较父节点（划分前）、子女结点（划分后）的不纯度变化。信息增益：$$\Delta = I(parent)-\sum_{j=1}^{k}\frac{N(v_{j})}{N}I(v_{j})$$其中 $I$ 为不纯度的度量，关于 $N$ 的计算是划分后的个数加权。$I$ 为熵（Entropy）的时候，$\Delta$ 为信息增益。信息增益率（Gain Ratio）：$$GainRatio=\frac{\Delta_{info}}{SplitInfo}=\frac{\Delta_{info}}{-\sum_{i=0}^{c-1}p(i)log_{2}p(i)}$$使用信息增益率，好处是把属性测试条件产生的输出数也考虑进去。说明如果某个属性产生了大量的划分，它的划分信息会很大，从而降低了增益率。注：信息增益、信息增益率，我们希望越大越好，表示变化。 （3）连续变量的划分：先对数据进行排序后，按照离散点的取值计算。Gini和熵趋向于有大量不同值的属性。 4、决策树算法（1）决策树归纳算法：1234567891011121314TreeGrowth(E,F): if stopping_cond(E,F)=true then leaf = createNode() leaf.label = Classify(E) return leaf else root = createNode() root.test_cond = find_best_split(E,F) 令V=&#123;v|v是root.test_cond集合&#125; for v in V do Ev = &#123;e|v条件下的数据集合&#125; child = TreeGrowth(Ev,F) 将child添加到树中去，将边(root-&gt;child)标记为v return root （2）决策树特点：1、是一种非参数方法，不要求任何的先验假设。2、找到最佳的决策树是NP完全问题。3、相对容易解释。4、对于噪声有相当好的鲁棒性。5、冗余属性不会对决策树准确率造成影响。即为强相关性，一个用于划分，另一个则将被忽略。相反，不相关的属性，可能在构建树的过程中被偶然选中，导致决策树过于庞大。6、数据碎片问题。当深度越深的时候，数据可能会太少，从而不能做出有统计意义的判断，当样本量小于某个阈值的时候，应该停止分裂。7、子树可能在决策树中重复多次，显得复杂，难以解释。 （3）斜决策树（oblique decision tree）：这里涉及到的决策树都是每次选取一个变量分子集划分，对某些数据集（连续属性有着复杂建模）缺乏划分能力。斜决策树可以克服这个问题。测试条件为：$$ x+y&lt;1$$另一种方法是，构造归纳法（constructive induction），该方法创建复合属性，代表已有的属性的算术、逻辑组合。构造归纳的花费较低，而斜决策树要动态的确定属性组合，但构造归纳会产生冗余属性。 5、模型过拟合分类模型误差分为：训练误差（training error）、泛化误差（generalization error）。一个好的模型需要有较低的泛化误差和训练误差。 奥卡姆剃刀（Occam’s razor）：给定两个具有相同泛化误差的模型，较简单的模型比较复杂的模型更可取。 悲观误差估计（pessimistic error estimate）：$$e_{g}(T)=\frac{\sum_{i=1}^{k}[e(t_{i})+\Omega (t_{i})]}{\sum_{i=1}^{k}n(t_{i})}=\frac{e(T)+\Omega(T)}{N_{t}}$$$k$是决策树的叶节点数目，$e(T)$为总训练误差，$N_{t}$为总训练样本数，$\Omega$为罚项。对二叉树来说，0.5的罚项意味着只要至少能够改善一个训练记录分类，结点就应当扩展，当1位罚项，意味着除非能够减少一个以上训练记录的误分类，否则结点不应当扩展。 先剪枝：当达到某个条件，提前终止。例如：当观察到某个不纯度度量低于某个确定阈值时就停止扩展叶结点，但是，难点在于很难确定正确终止的阈值。 后剪枝：初始按照最大规模生长，按照自底向上修剪决策树。修剪方式：（1）子树替换（subtree replacement）用叶结点替代子树，叶结点的类标号为子树的多数类；（2）子树提升（subtree raising）子树中最常使用的分支替代子树。后剪枝能产生更好的结果。 6、评估分类器性能自助法（bootstrap）：训练集是对于原数据集的有放回抽样，如果原始数据集$N$，可以证明，大小为$N$的自助样本大约包含原数据63.2%的记录。当$N$充分大的时候，$1-(1-\frac{1}{N})^{N}$ 概率逼近 $1-e^{-1}=0.632$。抽样 $b$ 次，产生 $b$ 个bootstrap样本，则，总准确率为（$acc_{s}$为包含所有样本计算的准确率）：$$ acc_{boot}=\frac{1}{b}\sum_{i=1}^{b}(0.632\times\varepsilon _{i}+0.368\times acc_{s})$$ 准确度的区间估计：将分类问题看做二项分布，则有：令 $X $为模型正确分类，$p$ 为准确率，$X $服从均值 $Np$、方差 $Np(1-p)$的二项分布。$acc=\frac{X}{N}$为均值 $p$，方差 $\frac{p(1-p)}{N}$ 的二项分布。$acc$ 的置信区间：$$ P\left(-Z_{\frac{\alpha }{2}} \leq \frac{acc-p}{\sqrt{p(1-p)/N}} \leq Z_{1-\frac{\alpha}{2}}\right)=1-\alpha$$$$ P\in\frac{2\times N \times acc +Z_{\frac{\alpha}{2}}^{2}\pm Z_{\frac{\alpha}{2}}\sqrt{Z_{\frac{\alpha}{2}}^{2}+4\times N \times acc-4\times N \times acc^{2}}}{2(N+Z_{\frac{\alpha}{2}}^{2})}$$]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据]]></title>
      <url>%2F2017%2F02%2F15%2FML_ITDM_data%2F</url>
      <content type="text"><![CDATA[一、数据知识如果若干属性是强相关的，则说明这些属性可能提供了高度冗余的信息，我们可以决定只保留一个。 二、数据预处理1、维规约：通过创建新属性，将一些旧属性合并在一起来降低数据的维度。通过选择旧属性的子集得到的新属性，这种维规约称为特征子集选择。 2、维灾难：数据维度（属性）过高。数据稀疏，对于分类，没有足够多的数据用于建模；对于聚类，点之间的密度和距离定义失去了意义，分类准确率降低。 3、数据离散化：将连续型变量离散化为离散型变量。 （1）非监督离散化： 这里注意K均值离散化是什么样的技术，去寻找资料。 （2）监督离散化：计算熵，希望获得最小的熵： $$ e_{i}=-\sum_{k}^{j=1}p_{ij}*log_{2}(p_{ij}) $$ $$ e=\sum_{i=1}^{n}w_{i}e_{i} $$ 其中e为该区间的熵。若纯：对于$p_{ij} = 0$或者1，$e_{i} = 0$若不纯：则熵最大。 4、变量变换标准化：创建一个变量，使得它有均值为0，标准差为1 $$ x’=\frac{x-\bar{x}}{s_{x}} $$ 均值和标准差受离群点的影响很大，通常需要使用其他变化，用中位数（median）代替均值，使用绝对标准差（absolute standard deviation）取代标准差。绝对标准差： $$ \sigma_{A}=\sum_{i=1}^{m}\left|x_{i}-\mu\right| $$ 三、属性的相似度和相异度1、相异度，距离闵可夫斯基距离（Minkowski distance）： $$ d(x,y)=\left(\sum_{k=1}^{n}\left|x_{k}-y_{k}\right|^{r}\right)^{\frac{1}{r}} $$ 注：$r=1$时，曼哈顿距离。$r=2$时，欧几里得距离。r=无穷时，上确界距离。距离的性质：（1）非负性；（2）对称性；（3）三角不等式。 2、相似度（1）简单匹配系数（Simple Matching Coefficient，SMC）$$ SMC=\frac{f_{11}+f_{00}}{f_{01}+f_{10}+f_{11}+f_{00}} $$ 其中$f_{11}$表示：x取1并且y取1的属性个数。其他类似。SMC可以是一个仅包含是非题的检测中用来发现回答问题相似的学生。 （2）Jaccard系数$$ J=\frac{f_{11}}{f_{01}+f_{10}+f_{11}} $$ 以上两个系数，均用于二元变量，0-1的计算。 （3）余弦相似度$$ cos(x,y)=\frac{x\cdot y}{\left | x \right |\left | y \right |}=\frac{x}{\left|x\right|}\cdot \frac{y}{\left|y\right|}=x’\cdot y’ $$ 余弦相似度从等式右边，可以看出不需要考虑量值。其中，有向量点积计算公式： $$ x\cdot y=\sum_{n}^{k=1}x_{k}y_{k},\left | x \right |=\sqrt{\sum_{n}^{k=1}x_{k}^{2}}=\sqrt{x\cdot x} $$ （4）广义Jaccard系数（Tanimoto系数，EJ）$$ EJ(x,y)=\frac{x\cdot y}{\left | x \right |^{2}+\left | y \right |^{2}-x\cdot y}$$ （5）相关性Pearson相关系数，[-1,1]之间： $$ corr(x,y)=\frac{S_{xy}}{S_{x}S_{y}}=\frac{\frac{1}{n-1}\sum_{k=1}^{n}(x_{k}-\bar{x})(y_{k}-\bar{y})}{\sqrt{\frac{1}{n-1}\sum_{k=1}^{n}(x_{k}-\bar{x})^{2}}\cdot \sqrt{\frac{1}{n-1}\sum_{k=1}^{n}(y_{k}-\bar{y})^{2}}}$$ Bregman散度：失真函数，损失函数。y为原来的点，x为某个失真值。给定一个严格凸函数，Bregman散度D（x，y）： $$ D(x,y)=\phi (x)+\phi (y)-\left \langle \triangledown \phi(y),(x-y) \right \rangle$$ 后面的为梯度和内积。 $y=1$时，在$x=2$和$x=3$上的Bregman散度。 （6）马氏距离（Mahalanobis距离）$$ mahalanobis(x,y)=(x-y)\Sigma ^{-1}(x-y)^{T}$$ x，y为两个点，中间的为数据协方差的逆。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[cmd设置命令缓存（伪别名）]]></title>
      <url>%2F2017%2F02%2F14%2Fwindows_bat_alias%2F</url>
      <content type="text"><![CDATA[1、创建一个bat文件，alias.bat，内容如下：123doskey ls=dirdoskey python3=C:\Users\xxxx\Anaconda3\python.exedoskey pip3=C:\Users\xxxx\Anaconda3\Scripts\pip.exe 2、该文件保存于任意目录下，目录最好为英文，C:\Users\xxxx。3、win+r，输入regedit，打开注册表。12HKEY_LOCAL_MACHINE\Software\Microsoft\CommandHKEY_CURRENT_USER\Software\Microsoft\Command 不过，可能没有AutoRun这个键，可以自己添加：右键——新建——字符串值，输入“AutoRun”，然后选中——右键——修改，把路径输入进去，大概像上图那样，然后关掉就可以了（这里我只改了CURRENT_USER的，没改HKEY_LOCAL_MACHINE，因为我觉得这样基本就够用了） 但是。这只是建立一个缓存，并不是真正意义上的别名。自己尝试过只能直接使用“别名”，不能在“别名”的后面添加别的参数。如：pip3 list不能列出已安装的包，只能显示pip的帮助，相当于仅仅在命令行里输入C:\Users\xxxx\Anaconda3\Scripts\pip.exe，而不是C:\Users\xxxx\Anaconda3\Scripts\pip.exe list。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[awk]]></title>
      <url>%2F2017%2F01%2F24%2Flinux_awk%2F</url>
      <content type="text"><![CDATA[1、简单例子1awk &apos;BEGIN &#123;print &quot;Hello world!&quot;&#125;&apos; # 这个不需要文件输入就可以 awkscr文件：1/^$/ &#123;print &quot;This is a blank line&quot;&#125; 运行脚本文件awkscr对应于test文件：1awk -f awkscr test 例子1echo a b c d | awk &apos;&#123;one=1;two=2&#125;&#123;print $(one + two)&#125;&apos; -F “\t” ：表示分隔符为\tFS：表示分隔符 灵活指定分隔符，正则指定1234BEGIN &#123;FS=&quot;,&quot;&#125;&#123;print $1 &quot;,&quot; $6&#125; # 使用，为分隔符FS=&quot;\t&quot; # 指定一个 tab 为分隔符FS=&quot;\t+&quot; # 指定一个以上的 tab 为分隔符【正则】FS=&quot;[&apos;:\t]&quot; # 指定&apos;、:、 tab 中任何一个为分隔符 2、模式匹配123awk &apos;/^$/ &#123;print &quot;This is a blank line&quot;&#125;&apos; testawk &apos;/[0-9]/ &#123;print &quot;This is a blank line&quot;&#125;&apos; testawk &apos;/[A-Za-z]/ &#123;print &quot;This is a blank line&quot;&#125;&apos; test http://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html http://awk.readthedocs.io/en/latest/chapter-one.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sz-rz-文件传输]]></title>
      <url>%2F2017%2F01%2F24%2Flinux_03_rzsz%2F</url>
      <content type="text"><![CDATA[Xshell1、sz用法（下载）：下载一个文件1sz filename 下载多个文件1sz filename1 filename2 下载dir目录下的所有文件，不包含dir下的文件夹1sz dir/* 2、rz用法（上传）：输入rz回车后，会出现文件选择对话框，选择需要上传文件，一次可以指定多个文件，上传到服务器的路径为当前执行rz命令的目录。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux 查看系统信息命令(比较全)]]></title>
      <url>%2F2017%2F01%2F24%2Flinux_02_com%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637# uname -a # 查看内核/操作系统/CPU信息# head -n 1 /etc/issue # 查看操作系统版本# cat /proc/cpuinfo # 查看CPU信息# hostname # 查看计算机名# lspci -tv # 列出所有PCI设备# lsusb -tv # 列出所有USB设备# lsmod # 列出加载的内核模块# env # 查看环境变量资源# free -m # 查看内存使用量和交换区使用量# df -h # 查看各分区使用情况# du -sh &lt;目录名&gt; # 查看指定目录的大小# grep MemTotal /proc/meminfo # 查看内存总量# grep MemFree /proc/meminfo # 查看空闲内存量# uptime # 查看系统运行时间、用户数、负载# cat /proc/loadavg # 查看系统负载磁盘和分区# mount | column -t # 查看挂接的分区状态# fdisk -l # 查看所有分区# swapon -s # 查看所有交换分区# hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备)# dmesg | grep IDE # 查看启动时IDE设备检测状况网络# ifconfig # 查看所有网络接口的属性# iptables -L # 查看防火墙设置# route -n # 查看路由表# netstat -lntp # 查看所有监听端口# netstat -antp # 查看所有已经建立的连接# netstat -s # 查看网络统计信息进程# ps -ef # 查看所有进程# top # 实时显示进程状态用户# w # 查看活动用户# id &lt;用户名&gt; # 查看指定用户信息# last # 查看用户登录日志# cut -d: -f1 /etc/passwd # 查看系统所有用户# cut -d: -f1 /etc/group # 查看系统所有组# crontab -l # 查看当前用户的计划任务服务# chkconfig –list # 列出所有系统服务# chkconfig –list | grep on # 列出所有启动的系统服务程序# rpm -qa # 查看所有安装的软件包]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一些常用命令]]></title>
      <url>%2F2017%2F01%2F24%2Flinux_01_base%2F</url>
      <content type="text"><![CDATA[一、基本命令（1）查看linux的信息12345uname -alsb_release -acat /etc/redhat-release # 查看服务器是Ubuntu还是Centosfile /sbin/init 或者file /bin/ls # 查看服务器是32、64位free -g # 以G为单位，查看内存大小 （2）查看某文件夹下，文件夹的文件大小总和1du -h --max-depth=1 # 深度为1的文件夹里面文件的总大小 （3）查找某文件的路径1find /data0 -name filename # /data0表示目录文件，只找/data0下的名字叫filename的文件 （4）管道使用ls1find /data0 -name filename | xargs ls -l 二、基本配置（1）vim使用鼠标在.vimrc中添加set mouse=a这句话，具体还有别的模式，这里不在叙述，尝试用a最合适。 （2）vim显示行号1:set number 三、日期命令输出日期1234567date=`date -d &quot;+0 day $1&quot; +%Y-%m-%d`enddate=`date -d &quot;+1 day $2&quot; +%Y-%m-%d`while [[ $date &lt; $enddate ]]do echo $date date=`date -d &quot;+1 day $date&quot; +%Y-%m-%d`done 123451) ls -lt 时间最近的在前面2) ls -ltr 时间从前到后3) 利用sort ls -l | sort +7 (日期为第8列) 时间从前到后 ls -l | sort -r +7 时间最近的在前面 四、查看进程和杀死进程123ps -efps -auxkill -s 9 1827 # 9是强制、尽快终止进程。1827是PID进程号 五、命令1wc -l filename # 显示文件的行数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[例子]]></title>
      <url>%2F2017%2F01%2F22%2Fhive_hadoop_example%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617CREATE TABLE dev.tmp_check_sku_20161202ASSELECT a.item_sku_id, b.sku_idFROM (SELECT item_sku_id,dt FROM gdm.gdm_m03_item_sku_da WHERE dt= &apos;2016-10-08&apos; AND sku_valid_flag=1) A FULL OUTER JOIN (SELECT sku_id,dt FROM gdm.gdm_m08_item_stock_day_sum WHERE dt= &apos;2016-10-08&apos; ) B ON a.item_sku_id=b.sku_id 1234567891011121314-- 统计数据SELECT CASE WHEN item_sku_id IS NOT NULL THEN 1 ELSE 0 END AS item_sku_cnt, CASE WHEN sku_id IS NOT NULL THEN 1 ELSE 0 END AS sku_cnt, count(1)FROM dev.tmp_check_sku_20161202GROUP BY CASE WHEN item_sku_id IS NOT NULL THEN 1 ELSE 0 END, CASE WHEN sku_id IS NOT NULL THEN 1 ELSE 0 END-- 结果1 0 1 7074892 1 0 8320842583 1 1 81142196]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基本命令]]></title>
      <url>%2F2017%2F01%2F22%2Fhive_hadoop_base%2F</url>
      <content type="text"><![CDATA[1、设置动态分区12set hive.exec.dynamic.partition=true;set hive.exec.dynamic.partition.mode=nonstrict; 2、设置最大动态分区12set hive.exec.max.dynamic.partitions=2000;set hive.exec.max.dynamic.partitions.pernode=2000; 3、创建动态分区表12345678910111213141516CREATE TABLE IF NOT EXISTS dev.dev_allocation_sale_data ( org_dc_id string, sale_ord_det_id string, sale_ord_id string, parent_sale_ord_id string, item_sku_id string, -- skuid sale_qtty int, -- 销售数量 sale_ord_tm string, -- 销售订单订购时间 sale_ord_type string, -- 订单配送类型 sale_ord_white_flag string, -- 是否包括白名单 item_third_cate_cd string, --sku所属三级分类 item_second_cate_cd string, --sku所属二级分类 shelves_dt string, --上架日期 shelves_tm string --上架时间 ) PARTITIONED by (date_s string,dc_id int); 4、插入动态分区表1234567891011121314insert overwrite table dev.dev_allocation_sale_data partition(date_s,dc_id)select a.org_dc_id, case when b.sale_ord_id is not null then &apos;rdc&apos; when c.sale_ord_id is not null then &apos;fdc_rdc&apos; when d.sale_ord_id is not null then &apos;fdc&apos; else &apos;other&apos; end, d.white_flag, a.item_third_cate_cd, a.item_second_cate_cd, a.shelves_dt, a.shelves_tm, a.dt as date_s, a.dc_idfrom dev.tmp_allocation_order_data_mid01 a 5、取出hive数据12INSERT OVERWRITE LOCAL DIRECTORY &apos;/home/cmo_ipc/Allocation_shell/datasets/sku_datasets&apos; select * from dev.dev_allocation_fdc_data; 动态分区http://blog.csdn.net/kntao/article/details/38683645 http://blog.csdn.net/chenyi8888/article/details/8236726]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[virtualenv 模块 虚拟环境]]></title>
      <url>%2F2017%2F01%2F14%2Fpython_virtualenv%2F</url>
      <content type="text"><![CDATA[1、安装virtualenv1pip install virtualenv 2、进入到某个文件夹创建纯净python2环境123mkdir workspacecd workspacevirtualenv python2 或者使用pycharm，也可以生成虚拟环境，不用的时候，直接删除文件就可以了。进入虚拟环境后，pip安装时独立的，不会影响。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python-dcox 模块 生成Word、docx文件]]></title>
      <url>%2F2017%2F01%2F12%2Fpython_python-dcox%2F</url>
      <content type="text"><![CDATA[http://python-docx.readthedocs.io/en/latest/index.html生成word的利器！ 一、快速开始12from docx import Documentdocument = Document() 1、段落加一个段落，下面paragraph是前面内容的光标指向，后面再该处插入一句话。12paragraph = document.add_paragraph(&apos;Lorem ipsum dolor sit amet.&apos;)prior_paragraph = paragraph.insert_paragraph_before(&apos;Lorem ipsum&apos;) 后面加一句话12paragraph = document.add_paragraph(&apos;Lorem ipsum &apos;)paragraph.add_run(&apos;dolor sit amet.&apos;) 添加段落风格1document.add_paragraph(&apos;Lorem ipsum dolor sit amet.&apos;, style=&apos;ListBullet&apos;) 使用blod、italic 等等12345paragraph = document.add_paragraph(&apos;Lorem ipsum &apos;)run = paragraph.add_run(&apos;dolor&apos;)run.bold = Truerun.italic = Trueparagraph.add_run(&apos;dolor&apos;).bold = True 2、标题level表示标题的大小1document.add_heading(&apos;The role of dolphins&apos;, level=2) 3、分页1document.add_page_break() 4、表格1table = document.add_table(rows=2, cols=2) 访问方法：取出来，单独赋值12cell = table.cell(0, 1)cell.text = &apos;parrot, possibly dead&apos; 依然使用二维数组类似的索引。123row = table.rows[1]row.cells[0].text = &apos;Foo bar to you.&apos;row.cells[1].text = &apos;And a hearty foo bar to you too sir!&apos; 分清楚结构123for row in table.rows: for cell in row.cells: print(cell.text) 查看信息12row_count = len(table.rows)col_count = len(table.columns) 添加一行1row = table.add_row() 动态添加表格123456789101112table = document.add_table(1, 3)# 标题heading_cells = table.rows[0].cellsheading_cells[0].text = &apos;Qty&apos;heading_cells[1].text = &apos;SKU&apos;heading_cells[2].text = &apos;Description&apos;# 添加内容for item in items: cells = table.add_row().cells cells[0].text = str(item.column1) cells[1].text = item.column2 cells[2].text = item.column3 5、添加图片12from docx.shared import Inchesdocument.add_picture(&apos;image-filename.png&apos;, width=Inches(1.25), height=Inches(1.25)) 二、操作document只能打开07之后的，会覆盖。12document = Document(&apos;existing-document-file.docx&apos;)document.save(&apos;new-file-name.docx&apos;) 打开文件1234567891011f = open(&apos;foobar.docx&apos;, &apos;rb&apos;)document = Document(f)f.close()# orwith open(&apos;foobar.docx&apos;, &apos;rb&apos;) as f: source_stream = StringIO(f.read())document = Document(source_stream)source_stream.close()...target_stream = StringIO()document.save(target_stream) 三、操作text段落居中12345from docx.enum.text import WD_ALIGN_PARAGRAPHdocument = Document()paragraph = document.add_paragraph()paragraph_format = paragraph.paragraph_formatparagraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER 左边整体缩进1234from docx.shared import Inchesparagraph = document.add_paragraph()paragraph_format = paragraph.paragraph_formatparagraph_format.left_indent = Inches(0.5) 右边整体缩进12from docx.shared import Ptparagraph_format.right_indent = Pt(24) 首行缩进1paragraph_format.first_line_indent = Inches(-0.25) 从字体调节，字体大小123456run = document.add_paragraph().add_run()font = run.fontfrom docx.shared import Ptfont.size = Pt(10.5) # 5号字体font.italic = Truefont.underline = True 字体颜色12from docx.shared import RGBColorfont.color.rgb = RGBColor(0x42, 0x24, 0xE9)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[pickle 模块 序列化]]></title>
      <url>%2F2017%2F01%2F12%2Fpython_pickle%2F</url>
      <content type="text"><![CDATA[使用pickle模块将数据对象保存到文件123456789101112131415161718import pickle data1 = &#123;&apos;a&apos;: [1, 2.0, 3, 4+6j], &apos;b&apos;: (&apos;string&apos;, u&apos;Unicode string&apos;), &apos;c&apos;: None&#125; selfref_list = [1, 2, 3]selfref_list.append(selfref_list) output = open(&apos;data.pkl&apos;, &apos;wb&apos;) # Pickle dictionary using protocol 0.pickle.dump(data1, output) # Pickle the list using the highest protocol available.pickle.dump(selfref_list, output, -1) output.close() 使用pickle模块从文件中重构python对象1234567891011import pprint, pickle pkl_file = open(&apos;data.pkl&apos;, &apos;rb&apos;) data1 = pickle.load(pkl_file)pprint.pprint(data1) data2 = pickle.load(pkl_file)pprint.pprint(data2) pkl_file.close()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[os/sys 模块 python操作文件路径]]></title>
      <url>%2F2017%2F01%2F12%2Fpython_os_sys%2F</url>
      <content type="text"><![CDATA[当前路径：123# -*- coding: utf-8 -*-import sys, ospwd = sys.path[0] # 获取当前执行脚本的位置 参数： `file`：当前文件完整路径，包括文件名 os.path.dirname(file): 某个文件所在的目录路径 os.path.join(a, b, c,….): 路径构造 a/b/c os.path.abspath(path): 将path从相对路径转成绝对路径 os.pardir: Linux下相当于”../“，上一级目录的标志 1os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir, os.pardir)) 搜索当前文件的前n__file__ = r’D:\Lgb\ipc_inv_opt\src\com\xxx\pbs\analysis\test.py’运行uppath(4)定位到 r’D:\Lgb\ipc_inv_opt\src’[analysis]-pbs-xxx-com-src1234def uppath(n=1): if n == 0: return os.path.abspath(os.path.dirname(__file__)) return os.path.abspath(os.path.join(os.path.dirname(__file__), (os.pardir + os.sep) * (n - 1) + os.pardir)) 1、判断文件夹存在12if os.path.exists(total_path) == False: os.mkdir(total_path) 2、添加当前目录到 import 的路径中，当前目录需要有init12sys.path.append(os.path.dirname(__file__))sys.path.append(os.path.dirname(os.path.dirname(__file__))) os.listdir() # 列出dirname下的目录和文件os.sep # 可以取代操作系统特定的路径分割符。os.name # 字符串指示你正在使用的平台。比如对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’。os.getcwd() # 函数得到当前工作目录，即当前Python脚本工作的目录路径。os.getenv()和os.putenv() # 函数分别用来读取和设置环境变量。os.listdir() # 返回指定目录下的所有文件和目录名。os.remove() # 函数用来删除一个文件。os.system() # 函数用来运行shell命令。os.linesep # 字符串给出当前平台使用的行终止符。例如，Windows使用’\r\n’，Linux使用’\n’而Mac使用’\r’。os.curdir # 返回但前目录（’.’)os.chdir(dirname) # 改变工作目录到dirnameos.path.isdir(name) # 判断name是不是一个目录，name不是目录就返回falseos.path.isfile(name) # 判断name是不是一个文件，不存在name也返回falseos.path.exists(name) # 判断是否存在文件或目录nameos.path.getsize(name) # 获得文件大小，如果name是目录返回0Los.path.abspath(name) # 获得绝对路径os.path.normpath(path) # 规范path字符串形式os.path.split(name) # 分割文件名与目录（事实上，如果你完全使用目录，它也会将最后一个目录作为文件名而分离，同时它不会判断文件或目录是否存在）os.path.splitext() # 分离文件名与扩展名os.path.join(path,name) # 连接目录与文件名或目录os.path.basename(path) # 返回文件名os.path.dirname(path) # 返回文件路径 3、python读取文件方法一、这种为一行一行去读12for line in open(&quot;foo.txt&quot;): print line, 方法二、这种为读取全部文件，然后在一行一行的去读1234f = open(&quot;c:\\1.txt&quot;,&quot;r&quot;) lines = f.readlines()#读取全部内容 for line in lines print line]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[matplotlib 画图风格]]></title>
      <url>%2F2016%2F12%2F25%2Fpython_matplotlib_style%2F</url>
      <content type="text"><![CDATA[123import matplotlib.style as mstyleprint mstyle.availableplt.style.use(&apos;seaborn-darkgrid&apos;) 可选风格：seaborn-darkgridseaborn-notebookclassicseaborn-ticksgrayscalebmhseaborn-talkdark_backgroundggplotfivethirtyeightseaborn-colorblindseaborn-deepseaborn-whitegridseaborn-brightseaborn-posterseaborn-mutedseaborn-paperseaborn-whiteseaborn-pastelseaborn-darkseaborn-dark-palette]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[matplotlib 使用中文]]></title>
      <url>%2F2016%2F12%2F25%2Fpython_matplotlib_Chinese%2F</url>
      <content type="text"><![CDATA[一、颜色调整绿色：#6AB27B土色：#a27712浅紫色：#8172B2蓝色：#4C72B0红色：#C44E52 二、使用中文123from pylab import mplmpl.rcParams[&apos;font.sans-serif&apos;] = [&apos;SimHei&apos;] # 使用中文mpl.rcParams[&apos;axes.unicode_minus&apos;] = False # 解决负号问题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[chardet 模块 编码检测]]></title>
      <url>%2F2016%2F12%2F25%2Fpython_chardet%2F</url>
      <content type="text"><![CDATA[一、基本用法使用detect函数输入字符串，输出检测的编码和置信度。123456import urllibrawdata = urllib.urlopen(&apos;http://yahoo.co.jp/&apos;).read()import chardetchardet.detect(rawdata)[out] &#123;&apos;encoding&apos;: &apos;EUC-JP&apos;, &apos;confidence&apos;: 0.99&#125; 二、高级用法处理大量文本，增量式的检测。12345678910111213import urllibfrom chardet.universaldetector import UniversalDetectorusock = urllib.urlopen(&apos;http://yahoo.co.jp/&apos;)detector = UniversalDetector()for line in usock.readlines(): detector.feed(line) if detector.done: breakdetector.close()usock.close()print detector.result[out] &#123;&apos;encoding&apos;: &apos;EUC-JP&apos;, &apos;confidence&apos;: 0.99&#125; 使用UniversalDetector()检测器，.feed（）添加检测文本，增量检测的时候，如果达到最小阈值，则.done的值为True。使用.close()关闭，.result为结果。 123456789101112import globfrom chardet.universaldetector import UniversalDetectordetector = UniversalDetector()for filename in glob.glob(&apos;*.xml&apos;): print filename.ljust(60), detector.reset() for line in file(filename, &apos;rb&apos;): detector.feed(line) if detector.done: break detector.close() print detector.result .reset()为UniversalDetector()检测器的重用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ANSII码和进制转换]]></title>
      <url>%2F2016%2F12%2F25%2Fpython_ANSII%2F</url>
      <content type="text"><![CDATA[一、进制转换bin()：其他进制数值 —&gt; 二进制字符串123[10=&gt;2]: bin(10) [8 =&gt;2]: bin(012) [16=&gt;2]: bin(0xa) oct()：其他进制数值 —&gt; 八进制字符串123[10=&gt;8]: oct(10) [2 =&gt;8]: oct(0b1010) [16=&gt;8]: oct(0xa) int()：其他进制数值 —&gt; 十进制字符串123[2=&gt;10]: int(0b1010) 、int(&quot;1010&quot;,2)、int(&quot;0b1010&quot;,2) [8=&gt;10]: int(012) 、int(&quot;12&quot;,8)、int(&quot;012&quot;,8) [16=&gt;10]: int(0xa)、int(&quot;0xa&quot;,16)、int(&quot;a&quot;,16) hex()：其他进制数值 —&gt; 十六进制字符串123[2 =&gt;16]: hex(0b1010)[8 =&gt;16]: hex(012) [10=&gt;16]: hex(10) 二、ASCII码转换chr(int)：整型 转 ASCII码1chr(97) ord(chr)：ASCII码 转 整型1ord(&quot;a&quot;) 三、位运算左移运算符（&lt;&lt;）右移运算符（&gt;&gt;）按位与（&amp;）按位或（|）按位翻转（～）按位异或（^）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Advanced Statistics]]></title>
      <url>%2F2016%2F11%2F19%2Fadvanced_statistics%2F</url>
      <content type="text"><![CDATA[Advanced StatisticsTransformations of Random VariablesLet me set the example;You have two independant random variables $X$ with pdf $f_{X}(x)$ and $Y$ with pdf $f_{Y}(y)$.You will have a new random variable $Z$, where $Z=X-Y$, and say we want to calculate the marginal pdf of $Z$.First we need to make a new joint pdf including Z, to avoid cluterization of the same random variables, lets first let give $X$ a different name, i.e. $X=W$.Now we saw that we have $Z=X-Y$, but now its $Z=W-Y$.We want to know our variable $Y$, so we re-arrange the above to get $Y=W-Z$. Now, we use something called a Jacobian, and we will use its determinant to transform from $(x,y)$ to $(w,z)$, and then we can get the marginal pdf of $Z$.So the jacobian is:$$|J|=|\frac{\partial(x,y)}{\partial(w,z)}|=\begin{vmatrix}\frac{\partial x}{\partial w} &amp; \frac{\partial y}{\partial w} \\\\frac{\partial x}{\partial z} &amp; \frac{\partial y}{\partial z}\end{vmatrix}$$We can then do the following:$$f_{Z,W}=f_{X,Y}(w,w-Z)|J|$$$$=f_{X}(w)f_{Y}(w-z) \cdot |J|$$And then finally, to find the marginal pdf of $Z$, we intergrate out w from the joint pdf:$$f_{Z}(z)=\int_{-\infty}^{\infty}f_{X}(w)f_{Y}(w-z)dw$$]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F11%2F19%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
